<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="record thinking and exploring">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://kujourinka.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="record thinking and exploring">
<meta property="og:locale">
<meta property="article:author" content="Kujou Rinka">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Rinka 的随笔</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kujourinka.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-re0_ss1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/08/re0_ss1/" class="article-date">
  <time class="dt-published" datetime="2023-08-08T15:00:00.000Z" itemprop="datePublished">2023-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/08/re0_ss1/">从零写一个 shadowsocks（1）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="0-引言"><a href="#0-引言" class="headerlink" title="0. 引言"></a>0. 引言</h3><p>类似 shadowsocks，v2ray，trojan 之类的代理软件原理，用一张很老的图就能概括：<br><img src="https://raw.githubusercontent.com/KujouRinka/flowchart/master/20230808/ss.png" alt="ss原理"></p>
<p>是不是很简单呀？那么今天我们就来简单实现一下。不过鉴于这种基石软件用的人数之多，网上想必也有很多类似的文章，我再写这种陈词滥调一是无聊，二是无用。所以我打算加一点新鲜东西，讲述一个代理软件是如何一步步将简单的转发流量的功能拓展到：</p>
<ul>
<li>多个监听和转发端口</li>
<li>支持多种协议</li>
<li>路由功能</li>
<li>…</li>
</ul>
<p>最主要的还是记录下我对这种软件的各个部件如何设计和组织的理解。</p>
<p>因此，写下本文的主要目的是：</p>
<ul>
<li>记录代理软件的原理和实现</li>
<li>描绘整个软件的设计框架</li>
<li><del>回顾下我是怎么写出这破代码的</del></li>
</ul>
<p>整个项目使用 C++ 编写，其中我使用了 <a target="_blank" rel="noopener" href="https://think-async.com/Asio/">asio</a> 库，真的很好用，谁用谁知道！</p>
<p>Let’s go!</p>
<h3 id="1-开始"><a href="#1-开始" class="headerlink" title="1. 开始"></a>1. 开始</h3><h5 id="从哪开始？"><a href="#从哪开始？" class="headerlink" title="从哪开始？"></a>从哪开始？</h5><p>就像老牛吃南瓜——无从下口，我们应该从哪里开始？代理软件的核心是转发流量，用 v2ray 中的名词，不管是 local 端还是 server 端，都需要 inbound（入站）和 outbound（出站）。由于 local 端和 server 端运行的是同一套软件，我们只需暂时将注意力集中在 local 上的设计即可。</p>
<p>现在我们再次将问题简化，设计一个仅将流量原封不动地转发到互联网的东西，它看起来就像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">         socks  +---------+          +----------+</span><br><span class="line">browser &lt;======&gt;| inbound |&lt;========&gt;| outbound |&lt;======&gt; internet</span><br><span class="line">                +---------+          +----------+</span><br></pre></td></tr></table></figure>

<h5 id="监听本地"><a href="#监听本地" class="headerlink" title="监听本地"></a>监听本地</h5><p>既然要转发流量，首先就要监听到流量，我们使用 <code>127.0.0.1:8888 </code> 作为监听地址监听本地流量。我们需要通过这个 socket 不断 accept 浏览器的请求，随后再通过读写通过 accept 得到的 socket 处理后续连接：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> io_context ctx;</span><br><span class="line"><span class="type">static</span> ip::<span class="function">tcp::acceptor <span class="title">listen_sock</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">    ip::tcp::endpoint(ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8888</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> tcp_sock = ip::tcp::socket;</span><br><span class="line"><span class="keyword">using</span> tcp_sock_p = shared_ptr&lt;tcp_sock&gt;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">tcp_sock_p <span class="title">sp</span><span class="params">(<span class="keyword">new</span> tcp_sock(ctx))</span></span>;</span><br><span class="line">  listen_sock.<span class="built_in">async_accept</span>(*sp, [sp](<span class="type">const</span> error_code err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 在这里处理通过 accept 得到的 socket</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">to_listen</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">to_listen</span>();</span><br><span class="line">  ctx.<span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是整个程序的入口，<code>to_listen()</code> 中通过调用 <code>listen_sock.async_accept()</code>，我们会把 remote sock 的信息写入到第一个参数，而作为第二个参数的 lambda 函数是 <code>async_accept()</code> 的 callback，这个函数会在 accept 工作完成，即，第一个参数被写入 remote sock 的信息后被调用；于是这个 callback 函数的逻辑就很清晰了：处理 remote sock，并调用 <code>to_listen()</code> 继续监听下一个到来的连接。</p>
<p>需要注意两点：</p>
<ul>
<li>这里处理 remote sock 的代码必须也是异步的，否则会阻塞监听下一个 sock</li>
<li>传入 <code>async_accept()</code> 的 sock 必须分配在堆上。原因是 <code>async_accept()</code> 作为异步函数会立即返回，<code>to_listen()</code> 可能在 <code>async_accept()</code> 完成工作前就早早返回，如果 sock 分配在栈上可能会被过早回收。</li>
</ul>
<p>我们已经得到了需要进行读写操作的 sock，而我们应该如何继续处理这个烫手山芋呢？</p>
<p>つづく</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kujourinka.github.io/2023/08/08/re0_ss1/" data-id="cll2gun8u0007d8p07hfyaha0" data-title="从零写一个 shadowsocks（1）" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-simple_impl_for_lazy" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/20/simple_impl_for_lazy/" class="article-date">
  <time class="dt-published" datetime="2023-04-20T09:00:00.000Z" itemprop="datePublished">2023-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/20/simple_impl_for_lazy/">简记一次 rCore 中 sys_sbrk() 与 lazy allocation 的实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="sbrk-的作用"><a href="#sbrk-的作用" class="headerlink" title="sbrk() 的作用"></a>sbrk() 的作用</h4><p><code>sbrk()</code> 系统是做什么的，可以参考<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/brk.2.html">这里</a>，简要来说，就是调整用户程序的堆（heap）顶位置，表现为对堆大小的增大或缩小。</p>
<h4 id="rCore-的地址空间布局与调整"><a href="#rCore-的地址空间布局与调整" class="headerlink" title="rCore 的地址空间布局与调整"></a>rCore 的地址空间布局与调整</h4><p>这里的 <code>sbrk()</code> 实现仅与用户虚拟地址空间有关。参考<a target="_blank" rel="noopener" href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/5kernel-app-spaces.html#term-vm-app-addr-space">这里</a>。</p>
<p>对于 rCore 原始布局，在低地址部分，从低地址往高地址依次为：<code>.text</code>，<code>.rodata</code>，<code>.data</code>，<code>.bss</code>，<code>guard page</code>，<code>user stack</code>，随后才是 <code>heap</code>：</p>
<p><img src="https://raw.githubusercontent.com/rcore-os/rCore-Tutorial-Book-v3/main/source/chapter4/app-as-full.png" alt="application address space"></p>
<p>但我对这个布局不太满意，于是通过修改 <code>mm::memory_set::MemorySet::from_elf()</code>，将空间布局修改为如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/// High 256GB</span><br><span class="line">/// +-------------------+</span><br><span class="line">/// |  Trampoline Code  |</span><br><span class="line">/// +-------------------+  &lt;- TRAMPOLINE</span><br><span class="line">/// |    TrapContext    |</span><br><span class="line">/// +-------------------+  &lt;- TRAP_CONTEXT, user_stack_top</span><br><span class="line">/// |    User Stack     |</span><br><span class="line">/// +-------------------+  &lt;- user_stack_bottom</span><br><span class="line">/// |       ...         |</span><br><span class="line">///</span><br><span class="line">/// Low 256GB</span><br><span class="line">/// |       ...         |</span><br><span class="line">/// +-------------------+</span><br><span class="line">/// |    Heap Memory    |</span><br><span class="line">/// +-------------------+  &lt;- heap_bottom</span><br><span class="line">/// |      .bss         |</span><br><span class="line">/// +-------------------+</span><br><span class="line">/// |      .data        |</span><br><span class="line">/// +-------------------+</span><br><span class="line">/// |      .rodata      |</span><br><span class="line">/// +-------------------+</span><br><span class="line">/// |      .text        |</span><br><span class="line">/// +-------------------+  &lt;- BASE_ADDRESS (0x10000 va)</span><br></pre></td></tr></table></figure>

<p>heap 紧挨着 bss 段，而 user stack 调整到高地址处。这么做的原因是当物理地址理论足够的情况下，可以方便 heap 和 user stack 的拓展，同时由于二者位置相差大，不太可能重叠，而原实现相较于此，user stack 的大小限制为 8K（即两个 PAGE SIZE），由由于其位置的特殊性，上有 heap 空间，下有 guard page，kernel 段，难以拓展。这个修改很简单，我们的重点不在这里。</p>
<h4 id="sbrk"><a href="#sbrk" class="headerlink" title="sbrk()"></a>sbrk()</h4><p>与其他的系统调用实现一样，先添加系统调用接口，再实现具体的逻辑。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_sbrk</span>(size: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(old_brk) = <span class="title function_ invoke__">change_program_brk</span>(size) &#123;</span><br><span class="line">    <span class="keyword">return</span> old_brk <span class="keyword">as</span> <span class="type">isize</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    -<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺着调用链，我们来到 <code>task::task::TaskControlBlock::change_brk()</code>，这是实际的 sbrk 的实现。主要的逻辑为根据判断传入的参数的正负判断堆空间的缩减，并更新相应的堆顶指针：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">old_brk</span> = <span class="keyword">self</span>.program_brk;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">new_brk</span> = <span class="keyword">self</span>.program_brk <span class="keyword">as</span> <span class="type">isize</span> + size <span class="keyword">as</span> <span class="type">isize</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">if</span> size &lt; <span class="number">0</span> &#123;</span><br><span class="line">  <span class="comment">// shrink heap</span></span><br><span class="line">  <span class="keyword">self</span>.memory_set.<span class="title function_ invoke__">shrink_to</span>(...)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// extend heap</span></span><br><span class="line">  <span class="keyword">self</span>.memory_set.<span class="title function_ invoke__">append_to</span>(...)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> result &#123;</span><br><span class="line">  <span class="keyword">self</span>.program_brk = new_brk <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">  <span class="title function_ invoke__">Some</span>(old_brk)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="literal">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缩小和扩大 heap 空间分别对应 <code>shrink_to</code> 和 <code>append_to</code> 两个函数，而二者的逻辑较为相似，这里以 <code>append_to</code> 为例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">append_to</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, new_end: VirtPageNum) &#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="variable">vpn</span> <span class="keyword">in</span> VPNRange::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>.vpn_range.<span class="title function_ invoke__">get_end</span>(), new_end) &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">map_one</span>(page_table, vpn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">self</span>.vpn_range = VPNRange::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>.vpn_range.<span class="title function_ invoke__">get_start</span>(), new_end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即朴实地为每一页在 PageTable 里创建一个映射，并没有什么花里胡哨的东西。</p>
<h4 id="lazy-alloc"><a href="#lazy-alloc" class="headerlink" title="lazy alloc"></a>lazy alloc</h4><p>lazy alloc 可以概括为：只标记，需要时分配。</p>
<p>具体来说：</p>
<ul>
<li>当调用 <code>sbrk()</code> 申请拓展 heap 空间，内核只增加堆顶指针（在这里是 <code>TaskControlBlock::program_brk</code>）的值，不做实际的内存分配，添加映射。用户程序访问这段内存会引起 PageFault，我们在处理该 Trap 的时候通过 <code>stval</code> 寄存器判断该地址是否位于 <code>heap_bottom</code> 和 <code>program_brk</code> 之间，若是，分配实际内存，添加页表映射；</li>
<li>当调用 <code>sbrk()</code> 申请缩小 heap 空间，需要减小 <code>program_brk</code> 的值，同时收回原堆顶和现堆顶之间的 page。</li>
</ul>
<h5 id="拓展-PageTable"><a href="#拓展-PageTable" class="headerlink" title="拓展 PageTable"></a>拓展 PageTable</h5><p>由于原实现中 <code>PageTable::map()</code> 和 <code>PageTable::unmap()</code> 在接口方面实现较为有限，我将其进行了拓展，将</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags, <span class="keyword">mut</span> frame: <span class="type">Option</span>&lt;FrameTracker&gt;);</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, dealloc: <span class="type">bool</span>);</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, args: MapArgs) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">MapArgs</span> &#123; vpn, ppn, flags, <span class="keyword">mut</span> frame &#125; = args;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, args: UnmapArgs) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">vpn</span> = args.vpn;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte</span>(vpn) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(pte) <span class="keyword">if</span> pte.<span class="title function_ invoke__">is_valid</span>() =&gt; pte,</span><br><span class="line">    _ =&gt; <span class="keyword">if</span> args.panic &#123;</span><br><span class="line">      <span class="built_in">panic!</span>(<span class="string">&quot;vpn &#123;:?&#125; should mapped but not&quot;</span>, vpn);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前，<code>MapArgs</code> 和 <code>UnmapArgs</code> 中字段足够使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MapArgs</span> &#123;</span><br><span class="line">  vpn: VirtPageNum,</span><br><span class="line">  ppn: PhysPageNum,</span><br><span class="line">  flags: PTEFlags,</span><br><span class="line">  frame: <span class="type">Option</span>&lt;FrameTracker&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">UnmapArgs</span> &#123;</span><br><span class="line">  vpn: VirtPageNum,</span><br><span class="line">  dealloc: <span class="type">bool</span>,</span><br><span class="line">  panic: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个内以设计模式中的 Builder 设计，使用一系列的 <code>with_...</code> 成员函数调整参数。</p>
<p>为了便于控制后续课程中 lazy_alloc 的使用与否，为 lazy alloc 新增一个 feature 并使用条件编译：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cargo.toml</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="section">[features]</span></span><br><span class="line"><span class="attr">default</span> = [<span class="string">&quot;sbrk_lazy_alloc&quot;</span>]</span><br><span class="line"><span class="attr">sbrk_lazy_alloc</span> = []</span><br></pre></td></tr></table></figure>

<h5 id="Trap"><a href="#Trap" class="headerlink" title="Trap"></a>Trap</h5><p><code>trap_handler</code> 中为 lazy alloc 添加的入口：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Trap::<span class="title function_ invoke__">Exception</span>(Exception::StoreFault)</span><br><span class="line">| Trap::<span class="title function_ invoke__">Exception</span>(Exception::StorePageFault)</span><br><span class="line">| Trap::<span class="title function_ invoke__">Exception</span>(Exception::LoadFault)</span><br><span class="line">| Trap::<span class="title function_ invoke__">Exception</span>(Exception::LoadPageFault) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">tcb</span> = <span class="title function_ invoke__">get_current_tcb_ref</span>();</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">ok</span> = <span class="keyword">if</span> stval &gt;= tcb.heap_bottom &amp;&amp; stval &lt; tcb.program_brk &#123;</span><br><span class="line">    <span class="comment">// lazy allocation for sbrk()</span></span><br><span class="line">    <span class="meta">#[cfg(feature = <span class="string">&quot;sbrk_lazy_alloc&quot;</span>)]</span> &#123;</span><br><span class="line">      <span class="title function_ invoke__">lazy_alloc_page</span>(stval.<span class="title function_ invoke__">into</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#[cfg(not(feature = <span class="string">&quot;sbrk_lazy_alloc&quot;</span>))]</span> &#123;</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>当判断 <code>stval</code> 中的地址为 heap 中的有效地址时，使用 <code>lazy_alloc_page()</code> 分配一页内存，实现较为简单，这里不过分说明。</p>
<h5 id="change-brk"><a href="#change-brk" class="headerlink" title="change_brk()"></a>change_brk()</h5><p>我们的重点是 <code>change_brk()</code> 的修改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">change_brk</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, size: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">usize</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">old_brk</span> = <span class="keyword">self</span>.program_brk;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">new_brk</span> = <span class="keyword">self</span>.program_brk <span class="keyword">as</span> <span class="type">isize</span> + size <span class="keyword">as</span> <span class="type">isize</span>;</span><br><span class="line">  <span class="keyword">if</span> new_brk &lt; <span class="keyword">self</span>.heap_bottom <span class="keyword">as</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">ok</span>;</span><br><span class="line">  cfg_if! &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="meta">#[cfg(feature = <span class="string">&quot;sbrk_lazy_alloc&quot;</span>)]</span> &#123;</span><br><span class="line">      ok = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> size &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.memory_set</span><br><span class="line">          .<span class="title function_ invoke__">remove_framed_area</span>(</span><br><span class="line">            VirtAddr::<span class="title function_ invoke__">from</span>(new_brk <span class="keyword">as</span> <span class="type">usize</span>),</span><br><span class="line">            VirtAddr::<span class="title function_ invoke__">from</span>(<span class="keyword">self</span>.program_brk),</span><br><span class="line">          );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    <span class="keyword">self</span>.program_brk = new_brk <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(old_brk)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到，当 <code>size &gt; 0</code> 我们仅仅增加了 <code>program_brk</code> 的值就返回，其他什么事也不做，而当该值小于 0，只增加了一点微不足道的操作：释放减少的那段空间。</p>
<p>至于为什么我拓展了 PageTable 的参数，下面以 <code>remove_framed_area</code> 为例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">remove_framed_area</span>(</span><br><span class="line">  &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">  start_va: VirtAddr,</span><br><span class="line">  end_va: VirtAddr,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="variable">vpn</span> <span class="keyword">in</span> VPNRange::<span class="title function_ invoke__">new</span>(start_va.<span class="title function_ invoke__">ceil</span>(), end_va.<span class="title function_ invoke__">floor</span>()) &#123;</span><br><span class="line">    <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">unmap</span>(</span><br><span class="line">      UnmapArgs::<span class="title function_ invoke__">builder</span>(vpn)</span><br><span class="line">        .<span class="title function_ invoke__">with_dealloc</span>(<span class="literal">true</span>)</span><br><span class="line">        .<span class="title function_ invoke__">with_panic</span>(<span class="literal">false</span>),</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们通过链式构造一步一步对 <code>UnmapArgs</code> 做出了要求，我们要求释放物理地址，并且保证不会 panic。这里我们为什么要保证不会 panic？由于原实现中的 <code>unmap()</code>，设计默认认为传给它的参数一定经过映射，当无法找到最后一级页表时，会认为是内核设计出现了 bug，于是直接通过 <code>unwarp()</code> 进行了 panic。</p>
<p>而这里我们释放 heap 空间，由于 lazy alloc 的存在，我们并不能事先知道哪些 page 被映射了而哪些没有，我们又不想付出额外的存储代价，于是选择对这段释放的空间的每一 page 进行遍历，其中有很大概率会遇见由于从未读写而未进行分配的 page，这样直接作为参数传给原来的 <code>unmap()</code> 必然会导致内核 panic，于是抽象出了 <code>unmap()</code> 的参数，为其添加 <code>panic</code> 字段，用于提示 <code>unmap()</code> 是否能够 panic。</p>
<p>最终的实现见 <a target="_blank" rel="noopener" href="https://github.com/KujouRinka/rCore/tree/876012b64189dd9c65e72743d4dbec9e72f22884">#876012b</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kujourinka.github.io/2023/04/20/simple_impl_for_lazy/" data-id="cll2gun8u0008d8p04qw9f7n0" data-title="简记一次 rCore 中 sys_sbrk() 与 lazy allocation 的实现" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-nic_driver_kara_syscall_he" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/21/nic_driver_kara_syscall_he/" class="article-date">
  <time class="dt-published" datetime="2023-03-21T15:00:00.000Z" itemprop="datePublished">2023-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/21/nic_driver_kara_syscall_he/">从网卡驱动到系统调用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="placeholder"><a href="#placeholder" class="headerlink" title="placeholder"></a>placeholder</h4><p>随着鸽了半年的操作系统的 lab 的完成，我对操作系统的实现的概念有了一定的了解，接下来便是对一些概念的熟悉了。</p>
<p>不过在此次前，我想记录一下我个人觉得最有意思的一部分：写一个简陋的网卡驱动。简单的任务涵盖了许多方面，这也是标题的由来。</p>
<p>先鸽一下，过几天有时间继续写🐦</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kujourinka.github.io/2023/03/21/nic_driver_kara_syscall_he/" data-id="cll2gun8t0006d8p0dqtj1jga" data-title="从网卡驱动到系统调用" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-6824_lab2a_leader_election" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/08/6824_lab2a_leader_election/" class="article-date">
  <time class="dt-published" datetime="2023-02-08T12:00:00.000Z" itemprop="datePublished">2023-02-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/08/6824_lab2a_leader_election/">6.824 Lab2A Leader Election 可行方案</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="一些碎碎念"><a href="#一些碎碎念" class="headerlink" title="一些碎碎念"></a>一些碎碎念</h4><p>书接上回，这是 6.824 的 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/lab-raft.html">lab2A</a>，实现 raft 协议中的 leader election。关于 raft 的更多详细内容，<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">raft paper</a> 和网络上大多数文章一定会比我在这里介绍得详细，这里只给出一个链接，以动图的方式助于理解 raft 的工作原理：<a target="_blank" rel="noopener" href="http://thesecretlivesofdata.com/raft/">Raft</a>，<a target="_blank" rel="noopener" href="https://raft.github.io/">https://raft.github.io/</a> 也提供了一个可交互的动画，大家可以去玩一玩。</p>
<p>个人的这个实现相较于网上的各种版本，代码量较大，但个人感觉逻辑更加清晰。</p>
<p>不保证 bug free，但使用课程中的 test 测试了近 1000 轮无一失败。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>实现 raft 协议中的 leader election。由 paper 中可知集群中的所有节点会选出一个 leader 节点，选出 leader 后其余节点均为 follower。对集群的各种操作都需要经过 leader 之手，具体表现为 client 直接向 leader 进行请求，或向 follower 请求，随后该 follower 将请求重定向到 leader。</p>
<p>对于单个节点，有三种可能的状态：</p>
<ul>
<li>follower</li>
<li>candidate</li>
<li>leader</li>
</ul>
<p>对于每个节点，有以下几种事件会导致状态间的转移：</p>
<ul>
<li>超时事件</li>
<li><strong>接收</strong>到来自 RequestVote RPC 的请求</li>
<li><strong>接收</strong>到来自 AppendEntries RPC 的请求</li>
</ul>
<p>同时由于处于 candidate 和 leader 状态下的节点分别会<strong>发出</strong> RequestVote 和 AppendEntries 请求，还应该在上面三个事件中加入：</p>
<ul>
<li>来自 RequestVote RPC 请求的回应</li>
<li>来自 AppendEntries RPC 请求的回应</li>
</ul>
<p>于是，整个 leader election 变成了一个填表游戏：</p>
<table>
<thead>
<tr>
<th align="center">事件\行为\状态</th>
<th align="center">follower</th>
<th align="center">candidate</th>
<th align="center">leader</th>
</tr>
</thead>
<tbody><tr>
<td align="center">timeout</td>
<td align="center">a</td>
<td align="center">d</td>
<td align="center">h</td>
</tr>
<tr>
<td align="center">RequestVote recv</td>
<td align="center">b</td>
<td align="center">e</td>
<td align="center">i</td>
</tr>
<tr>
<td align="center">AppendEntries recv</td>
<td align="center">c</td>
<td align="center">f</td>
<td align="center">j</td>
</tr>
<tr>
<td align="center">RequestVote callback</td>
<td align="center">&#x2F;</td>
<td align="center">g</td>
<td align="center">&#x2F;</td>
</tr>
<tr>
<td align="center">AppendEntries callback</td>
<td align="center">&#x2F;</td>
<td align="center">&#x2F;</td>
<td align="center">k</td>
</tr>
</tbody></table>
<p>当表填完，整个流程就基本完成了。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h5><h5 id="rpc-go"><a href="#rpc-go" class="headerlink" title="rpc.go"></a>rpc.go</h5><p>依照 paper 对 <code>rpc.go</code> 进行了一些修改：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------- for RequestVote ----------</span></span><br><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Your data here (2A, 2B).</span></span><br><span class="line">	Term        <span class="type">int</span> <span class="comment">// candidate&#x27;s curTerm</span></span><br><span class="line">	CandidateId <span class="type">int</span> <span class="comment">// candidate requesting vote</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RequestVoteReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Your data here (2A).</span></span><br><span class="line">	Term        <span class="type">int</span>  <span class="comment">// currentTerm, for candidate to update itself</span></span><br><span class="line">	VoteGranted <span class="type">bool</span> <span class="comment">// true means candidate received vote</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> voteParam <span class="keyword">struct</span> &#123;</span><br><span class="line">	args   *RequestVoteArgs</span><br><span class="line">	reply  *RequestVoteReply</span><br><span class="line">	notify <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">	<span class="comment">// Your code here (2A, 2B).</span></span><br><span class="line">	notify := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	rf.voteChan &lt;- voteParam&#123;args, reply, notify&#125;</span><br><span class="line">	&lt;-notify</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> sendRequestVote(server <span class="type">int</span>, args *RequestVoteArgs, reply *RequestVoteReply) <span class="type">bool</span> &#123;</span><br><span class="line">	ok := rf.peers[server].Call(<span class="string">&quot;Raft.RequestVote&quot;</span>, args, reply)</span><br><span class="line">	<span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- for AppendEntries ----------</span></span><br><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	Term     <span class="type">int</span> <span class="comment">// leader&#x27;s curTerm</span></span><br><span class="line">	LeaderId <span class="type">int</span> <span class="comment">// so follower can redirect clients</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	Term    <span class="type">int</span>  <span class="comment">// currentTerm, for leader to update itself</span></span><br><span class="line">	Success <span class="type">bool</span> <span class="comment">// true if follower contained entry matching prevLogIndex and prevLogTerm</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> appendEntryParam <span class="keyword">struct</span> &#123;</span><br><span class="line">	args   *AppendEntriesArgs</span><br><span class="line">	reply  *AppendEntriesReply</span><br><span class="line">	notify <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">	notify := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	rf.entryChan &lt;- appendEntryParam&#123;args, reply, notify&#125;</span><br><span class="line">	&lt;-notify</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> sendAppendEntries(server <span class="type">int</span>, args *AppendEntriesArgs, reply *AppendEntriesReply) <span class="type">bool</span> &#123;</span><br><span class="line">	ok := rf.peers[server].Call(<span class="string">&quot;Raft.AppendEntries&quot;</span>, args, reply)</span><br><span class="line">	<span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我并没有将处理的逻辑直接写到 RPC 处理函数中，而是将其封装到一个结构中，发送到一个专门用于接受这个参数的 channel 中，并传入一个空 channel 作同步作用。</p>
<h5 id="raft-go"><a href="#raft-go" class="headerlink" title="raft.go"></a>raft.go</h5><p>在 <code>type Raft struct</code> 中增加了一些 paper 中提到的本实现需要用到的字段，包括上面提到的接受 RPC 参数的 channel：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Your data here (2A, 2B, 2C).</span></span><br><span class="line"><span class="comment">// Look at the paper&#x27;s Figure 2 for a description of what</span></span><br><span class="line"><span class="comment">// state a Raft server must maintain.</span></span><br><span class="line">curTerm  <span class="type">int</span>    <span class="comment">// current curTerm</span></span><br><span class="line">state    RState <span class="comment">// current state</span></span><br><span class="line">votedFor <span class="type">int</span>    <span class="comment">// candidate id that received vote in current curTerm</span></span><br><span class="line"></span><br><span class="line">voteChan  <span class="keyword">chan</span> voteParam        <span class="comment">// channel for vote request</span></span><br><span class="line">entryChan <span class="keyword">chan</span> appendEntryParam <span class="comment">// channel for entry request</span></span><br></pre></td></tr></table></figure>

<p>有关 <code>RState interface</code> 和具体的实现，定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RState <span class="keyword">interface</span> &#123;</span><br><span class="line">	Run(tf *Raft)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Follower <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Candidate <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Leader <span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这里的设计参考了<a target="_blank" rel="noopener" href="https://book.douban.com/subject/34262305/">设计模式：可复用面向对象软件的基础</a>一书中的 State 模式，于是，便有了 <code>GetState</code> 函数的如下写法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> GetState() (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> rf.curTerm, reflect.TypeOf(rf.state) == reflect.TypeOf(&amp;Leader&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ticker</code> 函数也变得格外简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> ticker() &#123;</span><br><span class="line">	<span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">		rf.state.Run(rf)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Make</code> 函数只需要初始化我们添加的几个字段即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> *Raft &#123;</span><br><span class="line">	rf := &amp;Raft&#123;&#125;</span><br><span class="line">	rf.peers = peers</span><br><span class="line">	rf.persister = persister</span><br><span class="line">	rf.me = me</span><br><span class="line"></span><br><span class="line">	rf.curTerm = <span class="number">0</span></span><br><span class="line">	rf.state = &amp;Follower&#123;&#125;</span><br><span class="line">	rf.votedFor = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">	rf.voteChan = <span class="built_in">make</span>(<span class="keyword">chan</span> voteParam)</span><br><span class="line">	rf.entryChan = <span class="built_in">make</span>(<span class="keyword">chan</span> appendEntryParam)</span><br><span class="line">	rf.readPersist(persister.ReadRaftState())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// start ticker goroutine to start elections</span></span><br><span class="line">	<span class="keyword">go</span> rf.ticker()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="common-go"><a href="#common-go" class="headerlink" title="common.go"></a>common.go</h5><p>定义一些常用函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	ReElectLower = <span class="number">150</span></span><br><span class="line">	ReElectUpper = <span class="number">300</span></span><br><span class="line"></span><br><span class="line">	HeartBeatTimeout = <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randBetween</span><span class="params">(lower, upper <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> rand.Intn(upper-lower) + lower</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">electionTimeout</span><span class="params">()</span></span> time.Duration &#123;</span><br><span class="line">	<span class="keyword">return</span> time.Duration(randBetween(ReElectLower, ReElectUpper)) * time.Millisecond</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heartbeatTimeout</span><span class="params">()</span></span> time.Duration &#123;</span><br><span class="line">	<span class="keyword">return</span> time.Duration(HeartBeatTimeout) * time.Millisecond</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resetTimer</span><span class="params">(timer *time.Timer, timeout time.Duration)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !timer.Stop() &#123;</span><br><span class="line">		&lt;-timer.C</span><br><span class="line">	&#125;</span><br><span class="line">	timer.Reset(timeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重头戏"><a href="#重头戏" class="headerlink" title="重头戏"></a>重头戏</h4><p>下面正片开始，我将不同状态的逻辑分开写，虽然代码看上去挺长的，但是我感觉逻辑挺清晰的</p>
<h5 id="follower-go"><a href="#follower-go" class="headerlink" title="follower.go"></a>follower.go</h5><p>follower 是最简单的一个实现对照我上面画的一个表，只需要处理三个事件，大致框架如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Follower)</span></span> Run(rf *Raft) &#123;</span><br><span class="line">	timer := time.NewTimer(electionTimeout())</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">		<span class="comment">// a 处理超时</span></span><br><span class="line">		<span class="keyword">case</span> vote := &lt;-rf.voteChan:</span><br><span class="line">		<span class="comment">// b 处理 RequestVote 请求</span></span><br><span class="line">		<span class="keyword">case</span> entry := &lt;-rf.entryChan:</span><br><span class="line">		<span class="comment">// c 处理 AppendEntries 请求</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 follower 超时，自动变为 candidate，并为自己投票，因此，a 处填写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line">rf.state = &amp;Candidate&#123;&#125;</span><br><span class="line">rf.votedFor = rf.me</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>当 candidate 收到 RequestVote RPC 的请求，首先检查 <code>Term</code>，若小于 <code>curTerm</code> 则拒绝为其投票；若满足 <code>Term &gt; curTerm</code> 或者 <code>Term == curTerm &amp;&amp; vote.args.CandidateId</code>，同意为其投票，并重置超时计时器。b 处填写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vote.reply.Term = vote.args.Term</span><br><span class="line">vote.reply.VoteGranted = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">vote.args.CandidateId)</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> vote.args.Term &lt; rf.curTerm &#123;</span><br><span class="line">	rf.mu.Unlock()</span><br><span class="line">	vote.notify &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grant vote, update curTerm</span></span><br><span class="line"><span class="keyword">if</span> vote.args.Term &gt; rf.curTerm ||</span><br><span class="line">	(vote.args.Term == rf.curTerm &amp;&amp; rf.votedFor == vote.args.CandidateId) &#123;</span><br><span class="line">	rf.curTerm = vote.args.Term</span><br><span class="line">	rf.votedFor = vote.args.CandidateId</span><br><span class="line">	vote.reply.Term = rf.curTerm</span><br><span class="line">	vote.reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">	<span class="comment">// reset timer</span></span><br><span class="line">	resetTimer(timer, electionTimeout())</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">vote.notify &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这里提一嘴，<code>time.Timer</code> 和 <code>time.Ticker</code> 真的很容易用错，这里建议参考 golang 关于这两者的<a target="_blank" rel="noopener" href="https://pkg.go.dev/time">文档</a>。</p>
<p>当收到 AppendEntries RPC，同样依照 paper 中所说的检查任期等等逻辑如法炮制，c 处填写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">entry.args.LeaderId)</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> entry.args.Term &lt; rf.curTerm &#123;</span><br><span class="line">	<span class="comment">// stale curTerm, do nothing</span></span><br><span class="line">	entry.reply.Term = rf.curTerm</span><br><span class="line">	entry.reply.Success = <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> entry.args.Term &gt; rf.curTerm &#123;</span><br><span class="line">	<span class="comment">// larger curTerm, may this server is out of date</span></span><br><span class="line">	rf.curTerm = entry.args.Term</span><br><span class="line">	rf.votedFor = entry.args.LeaderId</span><br><span class="line">	entry.reply.Term = rf.curTerm</span><br><span class="line">	entry.reply.Success = <span class="literal">true</span></span><br><span class="line">	resetTimer(timer, electionTimeout())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// same curTerm, reset timer</span></span><br><span class="line">	entry.reply.Term = rf.curTerm</span><br><span class="line">	entry.reply.Success = <span class="literal">true</span></span><br><span class="line">	resetTimer(timer, electionTimeout())</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">entry.notify &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="candidate-go"><a href="#candidate-go" class="headerlink" title="candidate.go"></a>candidate.go</h5><p>先给出框架：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Candidate)</span></span> Run(rf *Raft) &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	rf.curTerm++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> send RequestVote RPC</span></span><br><span class="line">	rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	timer := time.NewTimer(electionTimeout())</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">		<span class="comment">// d 超时</span></span><br><span class="line">		<span class="keyword">case</span> reply := &lt;-replyChan:</span><br><span class="line">		<span class="comment">// g RequestVote 回答</span></span><br><span class="line">		<span class="keyword">case</span> vote := &lt;-rf.voteChan:</span><br><span class="line">		<span class="comment">// e RequestVote 请求</span></span><br><span class="line">		<span class="keyword">case</span> entry := &lt;-rf.entryChan:</span><br><span class="line">		<span class="comment">// f AppendEntries 请求</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先自增 curTerm，发送 RequestVote 请求其他节点的选票，随后开启循环等待事件驱动，其中 d，e，f 遵随 paper 所描述即可，只需要注意加锁释放锁的时机，这里简单贴一下代码：</p>
<p>d：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>e：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> vote.args.Term &gt; rf.curTerm &#123;</span><br><span class="line">	rf.curTerm = vote.args.Term</span><br><span class="line">	rf.votedFor = vote.args.CandidateId</span><br><span class="line">	rf.state = &amp;Follower&#123;&#125;</span><br><span class="line">	rf.mu.Unlock()</span><br><span class="line">	vote.reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">	vote.reply.Term = vote.args.Term</span><br><span class="line">	vote.notify &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> vote.args.Term &lt; rf.curTerm &#123;</span><br><span class="line">	vote.reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">	vote.reply.Term = rf.curTerm</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	vote.reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">	vote.reply.Term = rf.curTerm</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">vote.notify &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>f：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="comment">// a leader send AppendEntries, if args.term &gt;= curTerm</span></span><br><span class="line"><span class="comment">// acknowledge the leader and become follower</span></span><br><span class="line"><span class="comment">// or reject the request then stay as candidate</span></span><br><span class="line"><span class="keyword">if</span> entry.args.Term &gt;= rf.curTerm &#123;</span><br><span class="line">	rf.curTerm = entry.args.Term</span><br><span class="line">	rf.votedFor = entry.args.LeaderId</span><br><span class="line">	rf.state = &amp;Follower&#123;&#125;</span><br><span class="line">	rf.mu.Unlock()</span><br><span class="line">	entry.reply.Term = entry.args.Term</span><br><span class="line">	entry.reply.Success = <span class="literal">true</span></span><br><span class="line">	entry.notify &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	entry.reply.Term = rf.curTerm</span><br><span class="line">	entry.reply.Success = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">entry.notify &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>而 candidate 相较于 follower 多出来的逻辑部分就全部在下面了，我们需要在进入循环前以类似异步的方式发送 RequestVote 请求，并在循环中通过添加了一个 replyChan 进行处理 RequestVote 请求的回答。这样将请求和事件分开，逻辑没有那么混乱。于是，发送请求的代码为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send RequestVote RPC</span></span><br><span class="line">replyChan := <span class="built_in">make</span>(<span class="keyword">chan</span> RequestVoteReply, <span class="built_in">len</span>(rf.peers)<span class="number">-1</span>)</span><br><span class="line">args := RequestVoteArgs&#123;</span><br><span class="line">	Term:        rf.curTerm,</span><br><span class="line">	CandidateId: rf.me,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">	<span class="keyword">if</span> i == rf.me &#123;</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(pees *labrpc.ClientEnd)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> reply RequestVoteReply</span><br><span class="line">		<span class="keyword">if</span> pees.Call(<span class="string">&quot;Raft.RequestVote&quot;</span>, &amp;args, &amp;reply) &#123;</span><br><span class="line">			replyChan &lt;- reply</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(rf.peers[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grantedCnt := <span class="number">1</span></span><br><span class="line">minVote := <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>而对应的事件处理，当收到的选票大于集群数量的一半时，转换为 leader，但同时仍要处理任期 <code>Term</code>，g：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> reply.Term &gt; rf.curTerm &#123;</span><br><span class="line">	<span class="comment">// received larger term, become follower</span></span><br><span class="line">	rf.curTerm = reply.Term</span><br><span class="line">	rf.votedFor = <span class="number">-1</span></span><br><span class="line">	rf.state = &amp;Follower&#123;&#125;</span><br><span class="line">	rf.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> reply.Term == rf.curTerm &amp;&amp; reply.VoteGranted &#123;</span><br><span class="line">	<span class="comment">// received a grantVote</span></span><br><span class="line">	grantedCnt++</span><br><span class="line">	<span class="keyword">if</span> grantedCnt &gt;= minVote &#123;</span><br><span class="line">		rf.state = &amp;Leader&#123;&#125;</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br></pre></td></tr></table></figure>

<h5 id="leader-go"><a href="#leader-go" class="headerlink" title="leader.go"></a>leader.go</h5><p>框架：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Leader)</span></span> Run(rf *Raft) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> send heartbeat</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> send AppendEntries RPCs to all other servers</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// make heartbeat timer</span></span><br><span class="line">	timer := time.NewTimer(heartbeatTimeout())</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">		<span class="comment">// h 超时</span></span><br><span class="line">		<span class="keyword">case</span> reply := &lt;-replyChan:</span><br><span class="line">		<span class="comment">// k AppendEntries 回答</span></span><br><span class="line">		<span class="keyword">case</span> vote := &lt;-rf.voteChan:</span><br><span class="line">		<span class="comment">// i RequestVote 请求</span></span><br><span class="line">		<span class="keyword">case</span> entry := &lt;-rf.entryChan:</span><br><span class="line">		<span class="comment">// j AppendEntries 请求</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>h: 超时：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>i：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> vote.args.Term &gt; rf.curTerm &#123;</span><br><span class="line">	rf.curTerm = vote.args.Term</span><br><span class="line">	rf.votedFor = vote.args.CandidateId</span><br><span class="line">	rf.state = &amp;Follower&#123;&#125;</span><br><span class="line">	vote.reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">	vote.reply.Term = rf.curTerm</span><br><span class="line">	rf.mu.Unlock()</span><br><span class="line">	vote.notify &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> vote.args.Term &lt;= rf.curTerm &#123;</span><br><span class="line">	vote.reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">	vote.reply.Term = rf.curTerm</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">vote.notify &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>j：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> entry.args.Term &gt; rf.curTerm &#123;</span><br><span class="line">	rf.curTerm = entry.args.Term</span><br><span class="line">	rf.votedFor = entry.args.LeaderId</span><br><span class="line">	rf.state = &amp;Follower&#123;&#125;</span><br><span class="line">	entry.reply.Success = <span class="literal">true</span></span><br><span class="line">	entry.reply.Term = rf.curTerm</span><br><span class="line">	rf.mu.Unlock()</span><br><span class="line">	entry.notify &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> entry.args.Term &lt;= rf.curTerm &#123;</span><br><span class="line">	entry.reply.Success = <span class="literal">false</span></span><br><span class="line">	entry.reply.Term = rf.curTerm</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">entry.notify &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>模仿 RequestVote 的发送方式，发送 AppendEntries 请求，这个实验中只需要发送 heartbeat，实现起来并不困难：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send heartbeat</span></span><br><span class="line">rf.mu.Lock()</span><br><span class="line">replyChan := <span class="built_in">make</span>(<span class="keyword">chan</span> AppendEntriesReply, <span class="built_in">len</span>(rf.peers))</span><br><span class="line">args := AppendEntriesArgs&#123;</span><br><span class="line">	Term:     rf.curTerm,</span><br><span class="line">	LeaderId: rf.me,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// send AppendEntries RPCs to all other servers</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">	<span class="keyword">if</span> i == rf.me &#123;</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(peer *labrpc.ClientEnd)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> reply AppendEntriesReply</span><br><span class="line">		<span class="keyword">if</span> peer.Call(<span class="string">&quot;Raft.AppendEntries&quot;</span>, &amp;args, &amp;reply) &#123;</span><br><span class="line">			replyChan &lt;- reply</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(rf.peers[i])</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br></pre></td></tr></table></figure>

<p>k：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> vote.args.Term &gt; rf.curTerm &#123;</span><br><span class="line">	rf.curTerm = vote.args.Term</span><br><span class="line">	rf.votedFor = vote.args.CandidateId</span><br><span class="line">	rf.state = &amp;Follower&#123;&#125;</span><br><span class="line">	vote.reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">	vote.reply.Term = rf.curTerm</span><br><span class="line">	rf.mu.Unlock()</span><br><span class="line">	vote.notify &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> vote.args.Term &lt;= rf.curTerm &#123;</span><br><span class="line">	vote.reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">	vote.reply.Term = rf.curTerm</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">vote.notify &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>整个实验做下来的感觉：难，但是豁然开朗。明白了很多东西，很多细节需要处理，以及如何把握整个框架。写这么复杂的状态框架的原因是为了后续实验的更好拓展。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kujourinka.github.io/2023/02/08/6824_lab2a_leader_election/" data-id="cll2gun8n0001d8p0hzet6zcz" data-title="6.824 Lab2A Leader Election 可行方案" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-6824_lab1_MapReduce" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/12/23/6824_lab1_MapReduce/" class="article-date">
  <time class="dt-published" datetime="2022-12-23T14:00:00.000Z" itemprop="datePublished">2022-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/12/23/6824_lab1_MapReduce/">6.824 Lab1 MapReduce 快速实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这个是 MIT 6.824 分布式系统（Distributed Systems）2022 年的 lab1，<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">lab 链接</a>。字有点多，需要花些时间耐心读一下。</p>
<p>个人认为这个 Lab 在对 Golang 有一定了解的情况下不是很难实现，一定要把题意理解清楚，画一个大致框架再动手。我用了两天时间，第一天主要是读题（再次吐槽一下字有点多）和画大致框架，第二天花了一下午几个小时写了代码。Debug 没有难度，可能是我运气比较好，一把过2333</p>
<p>下面开始讲个人的实现，代码量不大，算上注释大致 200 行。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/KujouRinka/6.824-2022/commit/2f3c87aff43fc548f341853307b424d8ab37438e">rpc.go 的修改</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/KujouRinka/6.824-2022/commit/9b3fc49785e57b2846145c9082a162769456a2c7">coordinator.go 的修改</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/KujouRinka/6.824-2022/commit/e6833214404b7fb567d85ba9edc62444781ad9e7">worker.go 的修改</a></p>
<h4 id="复述"><a href="#复述" class="headerlink" title="复述"></a>复述</h4><p>实现 Google 曾经使用的 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">MapReduce</a> 的一个简单版本。具体的，修改<code>mr</code> 目录下的 <code>coordinator.go</code>，<code>rpc.go</code>，<code>worker.go</code> 三个文件实现 MapReduce</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>主要是修改 <code>coordinator.go</code> 和 <code>worker.go</code>，分别对于 pdf 文档中的 Master 和 Worker。前者负责调度任务，比如如何分配文件，如何规定超时任务的重新安排等等；后者负责实际执行 <code>map</code> 和 <code>reduce</code> 函数。</p>
<p>由于实际编写的是 coordinator 和 woker 的分布式版本，我们需要模拟这两个函数实际是在不同的机器上运行的，所以 coordinator 和 worker 两者的通信方式需要使用 RPC。于是，我们需要简单定义一下两者的通信方式：</p>
<ul>
<li>我们需要知道，需要先启动单个 coordinator，随后再启动多个 worker，这个测试脚本为我们做了，我们只需要了解。</li>
<li>worker 通过 <strong>RPC</strong> 向 coordinator 发送请求，表示“我现在空闲，请给我一个任务”。</li>
<li>由于 coordinator 已经注册了 RPC 服务（我们无需关注），其可以收到来自 worker 的 RPC 请求，我们从 coordinator 的任务队列中取出一个任务发送给 worker，并同时启动一个用于接收 worker 完成任务的方法和一个超时计时器。前者用于当 worker 完成任务时通知 coordinator；后者用于当 worker 没有按时完成任务时（paper 中解释的，可能 worker 崩溃了，或者网络阻塞等等），用于将任务重新安排给一个 worker。</li>
<li>当 worker 通过 RPC 获取到任务时，进行实际的工作。如果任务出错，直接终止等待下个任务即可，因为 coordinator 的计时器会帮我们重新安排这个任务；如果任务成功，再通过 RPC 告知 coordinator 任务已完成。若对 coordinator 的 RPC 调用失败，我们认为 coordinator 已经传输了所有的任务已退出，worker 可以终止。</li>
</ul>
<p>简单的流程图如下：</p>
<p><img src="https://raw.githubusercontent.com/KujouRinka/flowchart/master/cw_rpc.svg" alt="cw_rpc"></p>
<p>程序的流程是：</p>
<ul>
<li>我们通过对每个原始文件的内容作为 map 函数的参数输入，得到一组 <code>KeyValue</code>，对于不同的 <code>Key</code> 通过 <code>ihash(key) % nReduce</code> 计算出不同的 <code>key</code> 的 <code>reduceId</code> 将这个结果保存在 <code>mr-&#123;taskId&#125;-&#123;reduceId&#125;</code> 这个中间文件（intermediate）中。</li>
<li>当所有原始文件全部生成完对应的 <code>mr-&#123;taskId&#125;-&#123;reduceId&#125;</code> 文件后，coordinator 开始分配 reduce 函数的任务，于是每个 worker 只需要查找全部对应的 <code>reduceId</code> 的文件（具体的：<code>mr-*-&#123;reduceId&#125;</code>）进行合并处理和  <code>reduce</code> 调用即可。对于每个 <code>reduceId</code> ，生成对应的 <code>mr-out-&#123;reduceId&#125;</code> 文件。</li>
</ul>
<p>简单来说，就是：<code>pg*.txt</code> –&gt; <code>mr-1-0</code>, <code>mr-1-1</code>, …, <code>mr-2-0</code>, <code>mr-2-1</code>, … –&gt; <code>mr-out-0</code>, <code>mr-out-1</code>,… 这个流程。</p>
<h4 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h4><p>由于没有删除的代码，下面只列出添加的代码：</p>
<h5 id="rpc-go"><a href="#rpc-go" class="headerlink" title="rpc.go"></a>rpc.go</h5><p>首先添加一些 rpc 的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type     <span class="type">int</span>		<span class="comment">// 任务的类型，包括 Map 和 Reduce</span></span><br><span class="line">	Filename <span class="type">string</span>		<span class="comment">// 当 Type 为 Map 时字段有效，表示需要作用 Map 函数的文件的文件名</span></span><br><span class="line">	TaskId   <span class="type">int</span>		<span class="comment">// 用于标记这个 Task 的 Id，在对 Coordinator 回馈结果的时候作为参数返回</span></span><br><span class="line">	ReduceId <span class="type">int</span>		<span class="comment">// Coordinator 要求这个 Worker 统计的 Reduce 的 Id</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Map = <span class="literal">iota</span></span><br><span class="line">	Reduce</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个对应 Map 的 Task 结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMapTask</span><span class="params">(filename <span class="type">string</span>, taskId <span class="type">int</span>)</span></span> Task &#123;</span><br><span class="line">	<span class="keyword">return</span> Task&#123;</span><br><span class="line">		Type:     Map,</span><br><span class="line">		Filename: filename,</span><br><span class="line">		TaskId:   taskId,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个对应 Reduce 的 Task 的结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReduceTask</span><span class="params">(reduceId, taskId <span class="type">int</span>)</span></span> Task &#123;</span><br><span class="line">	<span class="keyword">return</span> Task&#123;</span><br><span class="line">		Type:     Reduce,</span><br><span class="line">		TaskId:   taskId,</span><br><span class="line">		ReduceId: reduceId,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NeedWork RPC: 用于请求 Coordinator 分配新的任务</span></span><br><span class="line"><span class="comment">// NeedWork 的参数</span></span><br><span class="line"><span class="keyword">type</span> NeedWorkArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NeedWork 的返回值</span></span><br><span class="line"><span class="keyword">type</span> NeedWorkReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	T         Task</span><br><span class="line">	ReduceCnt <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FinishWork RPC: 用于告知 Coordinator 任务已完成</span></span><br><span class="line"><span class="comment">// FinishWork 的参数</span></span><br><span class="line"><span class="keyword">type</span> FinishWorkArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	TaskId <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FinishWork 的返回值</span></span><br><span class="line"><span class="keyword">type</span> FinishWorkReply <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="worker-go"><a href="#worker-go" class="headerlink" title="worker.go"></a>worker.go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加的 import</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入的排序 interface，从 mrsequential.go copy 来</span></span><br><span class="line"><span class="comment">// for sorting by key.</span></span><br><span class="line"><span class="keyword">type</span> ByKey []KeyValue</span><br><span class="line"></span><br><span class="line"><span class="comment">// for sorting by key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span></span> Swap(i, j <span class="type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> a[i].Key &lt; a[j].Key &#125;</span><br></pre></td></tr></table></figure>

<p>下面是 <code>Worker</code> 函数的定义，全是感情，没有任何 Go 的技巧 :)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue,</span><br><span class="line">	reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		needWordReply := NeedWorkReply&#123;&#125;</span><br><span class="line">		ok := call(<span class="string">&quot;Coordinator.NeedWork&quot;</span>, &amp;NeedWorkArgs&#123;&#125;, &amp;needWordReply)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="comment">// 当 RPC 调用失败，我们认为 Coordinator 任务完成退出，</span></span><br><span class="line">			<span class="comment">// 所以 Worker 理应退出终止</span></span><br><span class="line">			<span class="comment">// Coordinator finish its work</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> needWordReply.T.Type == Map &#123;</span><br><span class="line">			<span class="comment">// 处理 Map 任务的逻辑</span></span><br><span class="line">			filename := needWordReply.T.Filename</span><br><span class="line">			file, err := os.Open(filename)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatalf(<span class="string">&quot;cannot open %v&quot;</span>, filename)</span><br><span class="line">			&#125;</span><br><span class="line">			content, err := io.ReadAll(file)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatalf(<span class="string">&quot;cannot read %v&quot;</span>, filename)</span><br><span class="line">			&#125;</span><br><span class="line">			file.Close()</span><br><span class="line">			<span class="comment">// 得到单个文件的 Key-Value</span></span><br><span class="line">			kva := mapf(filename, <span class="type">string</span>(content))</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 生成 intermediate 文件的逻辑</span></span><br><span class="line">			<span class="comment">// 首先计算每个 Key 的 reduceId，保存在 intermediate 这个二维切片中</span></span><br><span class="line">			intermediate := <span class="built_in">make</span>([][]KeyValue, needWordReply.ReduceCnt)</span><br><span class="line">			<span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line">				reduceTask := ihash(kv.Key) % needWordReply.ReduceCnt</span><br><span class="line">				intermediate[reduceTask] = <span class="built_in">append</span>(intermediate[reduceTask], kv)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// intermediate[i] 对应 mr-&#123;taskId&#125;-&#123;i&#125; 这个中间文件</span></span><br><span class="line">			<span class="comment">// 以 paper 中提示的使用 json 的方式写入</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; needWordReply.ReduceCnt; i++ &#123;</span><br><span class="line">				ofilename := fmt.Sprintf(<span class="string">&quot;mr-%d-%d&quot;</span>, needWordReply.T.TaskId, i)</span><br><span class="line">				<span class="comment">// ofile, _ := os.Create(ofilename)</span></span><br><span class="line">				tf, _ := os.CreateTemp(<span class="string">&quot;./&quot;</span>, ofilename)</span><br><span class="line">				enc := json.NewEncoder(tf)</span><br><span class="line">				<span class="keyword">for</span> _, kv := <span class="keyword">range</span> intermediate[i] &#123;</span><br><span class="line">					enc.Encode(&amp;kv)</span><br><span class="line">				&#125;</span><br><span class="line">				tf.Close()</span><br><span class="line">				os.Rename(tf.Name(), ofilename)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> needWordReply.T.Type == Reduce &#123;</span><br><span class="line">			<span class="comment">// 处理 Reduce 任务的逻辑</span></span><br><span class="line">			<span class="comment">// 找出目录下所有对应该 Reduce 的文件名</span></span><br><span class="line">			<span class="comment">// find all files corresponding to this reduce task</span></span><br><span class="line">			<span class="keyword">var</span> filenames []<span class="type">string</span></span><br><span class="line">			files, err := os.ReadDir(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatalf(<span class="string">&quot;cannot read current directory&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">				<span class="keyword">if</span> file.IsDir() &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				filename := file.Name()</span><br><span class="line">				prefix := <span class="string">&quot;mr-&quot;</span></span><br><span class="line">				suffix := fmt.Sprintf(<span class="string">&quot;-%d&quot;</span>, needWordReply.T.ReduceId)</span><br><span class="line">				<span class="keyword">if</span> strings.HasPrefix(filename, prefix) &amp;&amp; strings.HasSuffix(filename, suffix) &#123;</span><br><span class="line">					filenames = <span class="built_in">append</span>(filenames, filename)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 对所有已找到的文件进行读取</span></span><br><span class="line">			<span class="comment">// do reduce job</span></span><br><span class="line">			<span class="keyword">var</span> kva []KeyValue</span><br><span class="line">			<span class="keyword">for</span> _, filename := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">				file, err := os.Open(filename)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Fatalf(<span class="string">&quot;cannot open %v&quot;</span>, filename)</span><br><span class="line">				&#125;</span><br><span class="line">				dec := json.NewDecoder(file)</span><br><span class="line">				<span class="keyword">for</span> &#123;</span><br><span class="line">					<span class="keyword">var</span> kv KeyValue</span><br><span class="line">					<span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">break</span></span><br><span class="line">					&#125;</span><br><span class="line">					kva = <span class="built_in">append</span>(kva, kv)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 对该任务进行 Reduce 调用，逻辑和 mrsequential.go 完全一致，代码直接 copy</span></span><br><span class="line">			<span class="comment">// copy from mrsequential.go</span></span><br><span class="line">			sort.Sort(ByKey(kva))</span><br><span class="line">			oname := fmt.Sprintf(<span class="string">&quot;mr-out-%d&quot;</span>, needWordReply.T.ReduceId)</span><br><span class="line">			ofile, _ := os.Create(oname)</span><br><span class="line">			i := <span class="number">0</span></span><br><span class="line">			<span class="keyword">for</span> i &lt; <span class="built_in">len</span>(kva) &#123;</span><br><span class="line">				j := i + <span class="number">1</span></span><br><span class="line">				<span class="keyword">for</span> j &lt; <span class="built_in">len</span>(kva) &amp;&amp; kva[j].Key == kva[i].Key &#123;</span><br><span class="line">					j++</span><br><span class="line">				&#125;</span><br><span class="line">				values := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">				<span class="keyword">for</span> k := i; k &lt; j; k++ &#123;</span><br><span class="line">					values = <span class="built_in">append</span>(values, kva[k].Value)</span><br><span class="line">				&#125;</span><br><span class="line">				output := reducef(kva[i].Key, values)</span><br><span class="line">				fmt.Fprintf(ofile, <span class="string">&quot;%v %v\n&quot;</span>, kva[i].Key, output)</span><br><span class="line">				i = j</span><br><span class="line">			&#125;</span><br><span class="line">			ofile.Close()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// unknown task type</span></span><br><span class="line">			log.Fatalf(<span class="string">&quot;unknown task type: %v&quot;</span>, needWordReply.T.Type)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 运行到此代表该任务成功完成，通过 RPC 告知 Coordinator 任务完成</span></span><br><span class="line">		<span class="comment">// make FinishWork RPC call</span></span><br><span class="line">		call(<span class="string">&quot;Coordinator.FinishWork&quot;</span>, &amp;FinishWorkArgs&#123;TaskId: needWordReply.T.TaskId&#125;, &amp;FinishWorkReply&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// log.Printf(&quot;Worker: %v exit&quot;, os.Getpid())</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="coordinator-go"><a href="#coordinator-go" class="headerlink" title="coordinator.go"></a>coordinator.go</h5><p>个人认为 <code>coordinator.go</code> 的实现颇具技巧，网络上很多实现有大量评论代码“很不 Go”，没有 Go 的风格。</p>
<p>我虽说不是 Go 的高手，但也有一段时间具体学习了一下 Go 这门语言，参加了一些开源项目，对自己的代码风格还有有些信心，在这里自卖自夸一下2333，话不多说，先是 import：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>对 <code>Coordinator</code> 结构体的修改，添加了一些字段用于操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Your definitions here.</span></span><br><span class="line">	<span class="comment">// 保存一下 nReduce</span></span><br><span class="line">	nReduce <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义任务队列和任务的计数器，</span></span><br><span class="line">	<span class="comment">// 用于任务的发送，判断 Map 和 Reduce 任务的交界以及何时关闭 Coordinator</span></span><br><span class="line">	<span class="comment">// task sending definition</span></span><br><span class="line">	taskQueue <span class="keyword">chan</span> Task</span><br><span class="line">	taskWg    sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 任务 Id 计数器，自增</span></span><br><span class="line">	<span class="comment">// task id counter</span></span><br><span class="line">	taskIdCounter <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存用于通知任务完成的 chan 的字段，</span></span><br><span class="line">	<span class="comment">// 若 Worker 完成并调用 RPC，处理函数会向对应的 channel 发送一个信号</span></span><br><span class="line">	<span class="comment">// task notification record</span></span><br><span class="line">	taskNotifyMap  <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	taskNotifyLock sync.Mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于标记所有任务是否完成</span></span><br><span class="line">	<span class="comment">// done flag</span></span><br><span class="line">	done     <span class="type">bool</span></span><br><span class="line">	doneLock sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得一个新的 taskId</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> NewTaskId() <span class="type">int</span> &#123;</span><br><span class="line">	c.taskIdCounter++</span><br><span class="line">	<span class="keyword">return</span> c.taskIdCounter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Done 函数，返回所有任务是否已经完成</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> Done() <span class="type">bool</span> &#123;</span><br><span class="line">	c.doneLock.Lock()</span><br><span class="line">	ret := c.done</span><br><span class="line">	c.doneLock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Your code here.</span></span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MakeCoordinator</code> 函数的设计：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeCoordinator</span><span class="params">(files []<span class="type">string</span>, nReduce <span class="type">int</span>)</span></span> *Coordinator &#123;</span><br><span class="line">	<span class="comment">// 初始化一个 Coordinator</span></span><br><span class="line">	c := Coordinator&#123;</span><br><span class="line">		nReduce:       nReduce,</span><br><span class="line">		taskQueue:     <span class="built_in">make</span>(<span class="keyword">chan</span> Task, <span class="number">100</span>),</span><br><span class="line">		taskWg:        sync.WaitGroup&#123;&#125;,</span><br><span class="line">		taskIdCounter: <span class="number">0</span>,</span><br><span class="line">		taskNotifyMap: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		done:          <span class="literal">false</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// log.Printf(&quot;%d file found\n&quot;, len(files))</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 由于 Reduce 任务必须在所有 Map 任务完成后才能开始</span></span><br><span class="line">	<span class="comment">// 添加 Map 任务计数到 WaitGroup，用于标识所有的 Map 任务是否完成</span></span><br><span class="line">	c.taskWg.Add(<span class="built_in">len</span>(files))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启一个新的 goroutine 向 c.taskQueue channel 中发送任务</span></span><br><span class="line">	<span class="comment">// make send task goroutine</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(files []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 发送 Map 任务</span></span><br><span class="line">		<span class="comment">// send map task</span></span><br><span class="line">		<span class="keyword">for</span> _, filename := <span class="keyword">range</span> files &#123;</span><br><span class="line">			c.taskQueue &lt;- NewMapTask(filename, c.NewTaskId())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// log.Println(&quot;all task sent, waiting for next reduce task&quot;)</span></span><br><span class="line">		<span class="comment">// 等待所有 Map 任务完成，这时才能发送 Reduce 任务</span></span><br><span class="line">		<span class="comment">// wait for all map task done</span></span><br><span class="line">		c.taskWg.Wait()</span><br><span class="line">		<span class="comment">// log.Println(&quot;start sending reduce task&quot;)</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 添加 Reduce 任务的计数</span></span><br><span class="line">		<span class="comment">// send reduce task</span></span><br><span class="line">		c.taskWg.Add(nReduce)</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 下面这个 goroutine 的作用是</span></span><br><span class="line">		<span class="comment">// 等待 WaitGroup 值为 0 时，此时表示所有的 Reduce 任务也完成了</span></span><br><span class="line">		<span class="comment">// 所以可以将 c.done 置为 true，表示 Coordinator 可以结束了</span></span><br><span class="line">		<span class="comment">// make Done() check goroutine</span></span><br><span class="line">		<span class="comment">// log.Println(&quot;waiting exit goroutine created&quot;)</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.taskWg.Wait()</span><br><span class="line">			c.doneLock.Lock()</span><br><span class="line">			c.done = <span class="literal">true</span></span><br><span class="line">			c.doneLock.Unlock()</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="comment">// log.Println(&quot;sending reduce task&quot;)</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送 Reduce 任务</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nReduce; i++ &#123;</span><br><span class="line">			c.taskQueue &lt;- NewReduceTask(i, c.NewTaskId())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(files)</span><br><span class="line"></span><br><span class="line">	c.server()</span><br><span class="line">	<span class="keyword">return</span> &amp;c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NeedWork</code> RPC 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> NeedWork(args *NeedWorkArgs, reply *NeedWorkReply) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 从任务队列 c.taskQueue 中取出一个任务作为 RPC 返回值</span></span><br><span class="line">	task, ok := &lt;-c.taskQueue</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot get task from task queue&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	reply.T = task</span><br><span class="line">	reply.ReduceCnt = c.nReduce</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 taskId 作为唯一任务标识，创建一个 struct&#123;&#125; channel</span></span><br><span class="line">	<span class="comment">// 用于 FinishWork RPC 函数通知任务已被 Worker 完成</span></span><br><span class="line">	<span class="comment">// 注意锁的临界区，否则会导致 condition race</span></span><br><span class="line">	<span class="comment">// make task notification channel</span></span><br><span class="line">	c.taskNotifyLock.Lock()</span><br><span class="line">	c.taskNotifyMap[task.TaskId] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="comment">// 启动 goroutine 定时</span></span><br><span class="line">	<span class="comment">// set timer for task</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(taskChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-taskChan:</span><br><span class="line">			<span class="comment">// 任务完成</span></span><br><span class="line">			<span class="comment">// task done</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(<span class="number">10</span> * time.Second):</span><br><span class="line">			<span class="comment">// 任务超时，重新将任务放回任务队列中</span></span><br><span class="line">			c.taskQueue &lt;- task</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(c.taskNotifyMap[task.TaskId])</span><br><span class="line">	c.taskNotifyLock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FinishWork</code> RPC 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> FinishWork(args *FinishWorkArgs, reply *FinishWorkReply) <span class="type">error</span> &#123;</span><br><span class="line">	taskId := args.TaskId</span><br><span class="line">	c.taskNotifyLock.Lock()</span><br><span class="line">	<span class="comment">// 思考这里为什么要检查 taskId 所对应的值是否有效</span></span><br><span class="line">	<span class="comment">// 若考虑网络延迟之类的不确定因素，可能导致同一个 taskId 调用两次 FinishWork 函数</span></span><br><span class="line">	notifyChan, ok := c.taskNotifyMap[taskId]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		c.taskNotifyLock.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 向对应 channel 发送信号表示任务完成，同时任务计数 -1</span></span><br><span class="line">	<span class="comment">// notify task done</span></span><br><span class="line">	notifyChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	c.taskWg.Done()</span><br><span class="line">	<span class="comment">// log.Printf(&quot;task %d done\n&quot;, taskId)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除对应的 channel</span></span><br><span class="line">	<span class="comment">// delete task notification channel</span></span><br><span class="line">	<span class="built_in">delete</span>(c.taskNotifyMap, taskId)</span><br><span class="line">	c.taskNotifyLock.Unlock()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过这个实验我大致搞明白了一个简单的分布式系统由哪些部分组成。至此，分布式系统的 Lab1 完成，我认为难点不在代码的实现，而是题目的理解。更干净的代码实现见本人的 <a target="_blank" rel="noopener" href="https://github.com/KujouRinka/6.824-2022/commits/master">github commit history</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kujourinka.github.io/2022/12/23/6824_lab1_MapReduce/" data-id="cll2gun8i0000d8p061q241v7" data-title="6.824 Lab1 MapReduce 快速实现" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-6s018_lab5cow" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/12/04/6s018_lab5cow/" class="article-date">
  <time class="dt-published" datetime="2022-12-04T05:00:00.000Z" itemprop="datePublished">2022-12-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/12/04/6s018_lab5cow/">6.s018 lab5 cow(Copy-on-write fork) 踩坑指南</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>如题，不讲废话，直接开始。2020 年的 lab，<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/cow.html">lab 链接</a></p>
<h4 id="复述"><a href="#复述" class="headerlink" title="复述"></a>复述</h4><p>实现调用 <code>fork()</code> 时的写时复制，即 copy-on-write。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>根据提示：</p>
<ul>
<li><p>修改 <code>uvmcopy()</code> 函数。该函数仅会被 <code>fork()</code> 调用，原本用于将<strong>父进程</strong>的 pagetable 中所含的所有 page 复制到<strong>子进程</strong>的 pagetable 中，类似 deepcopy；修改后的 <code>uvmcopy()</code> 函数使用浅拷贝，子进程的 pagetable 结构与父进程完全一致。<strong>但同时</strong>，我们需要把父进程和子进<strong>两者</strong>的 pagetable 中的所有 pte 中，<code>PTE_W</code> 有效的 pte 的这一位清空，具体表现为使用 <code>*pte &amp;= ~PTE_W</code>。同时，我们需要使用 pte 中 <code>RSW</code> 中的其中一位，用于标记这个 pte 实现了 cow，这里我选择了使用第 8 位作为标记，定义为：<code>#define PTE_COWPG (1L &lt;&lt; 8)</code> 对 pte 做 <code>*pte |= PTE_COW</code> 操作。</p>
</li>
<li><p>修改 <code>usertrap()</code> 函数，为其添加 scause 处理入口。由 riscv 文档，我们仅需处理 15 号 code，该 code 代表 Store&#x2F;AMO page fault，而 13 号代表的 Load page fault 不在我们实现 cow 的处理范围内。在这个 scause 处理分支里，我们需要通过调用 <code>r_stval()</code> 得知导致 page fault 的<strong>虚拟</strong>地址，并<strong>一定</strong>要判断这个地址是否为合法的 cow 地址，若否，将进程标记为 killed 并返回，否则，复制 stval 地址中一个 page 的内容至新跑分配的空间，计算出正确的 pte 目录并重写。</p>
</li>
<li><p>这里是一步非常容易出错，即关于每一个 page 的引用计数 (Reference Count)。基本思路是维护一个关于每个 page 的 array，每个 page 对应其在 array 中的索引为该 page 的物理地址除以 PGSIZE(4096)，即 <code>pa / PGSIZE</code>，我们还能粗略计算出这个表的长度为 <code>PHYSTOP &gt;&gt; PGSHIFT</code>。对于：</p>
<ul>
<li><p>每次 <code>kalloc()</code> 调用，分配新的 page，我们对该 page 所对应的 rc 加 1</p>
</li>
<li><p>每次 <code>kfree()</code> 调用，将该 page 对应的 rc 减 1，若此时 rc 为 0，则真正释放这段内存，否则什么也不做。<br>这里，我们有如下定义：<code>#define RC_SZ PHYSTOP &gt;&gt; PGSHIFT</code></p>
</li>
<li><p><code>uvmcopy()</code> 中，对每个添加了 <code>PTE_COWPG</code> 的 pte 条目对应的<strong>物理地址</strong>的 rc 加 1</p>
</li>
<li><p><code>usertrap()</code> 中，在处理 cow 的分支中，对导致 page fault 的<strong>虚拟地址</strong>所对应的<strong>物理地址</strong>的 rc 减 1</p>
</li>
</ul>
</li>
</ul>
<p>而任何一步对 rc 的读写，需要进行<strong>加锁</strong>处理，否则会导致条件竞争，这种情况下，为 xv6 添加 <code>CPUS=1</code> 参数能勉强通过测试，但实际测试中无法得到正确结果。</p>
<ul>
<li>修改 <code>copyout()</code> 函数，这一步与在 scause 中所做的修改如出一辙，不再复述。</li>
</ul>
<h4 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h4><ul>
<li><code>defs.h</code>：添加几个导出的函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// kalloc.c</span></span><br><span class="line">+ <span class="type">void</span>            <span class="title function_">acquire_kmem</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">+ <span class="type">void</span>            <span class="title function_">release_kmem</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">+ <span class="type">void</span>            <span class="title function_">add_rc</span><span class="params">(uint64)</span>;</span><br><span class="line">+ <span class="type">void</span>            <span class="title function_">sub_rc</span><span class="params">(uint64)</span>;</span><br><span class="line">+ <span class="type">int</span>             <span class="title function_">get_rc</span><span class="params">(uint64)</span>;</span><br><span class="line">+ <span class="type">void</span>            <span class="title function_">set_rc</span><span class="params">(uint64, <span class="type">int</span>)</span>;</span><br><span class="line">  <span class="type">void</span>*           <span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">  <span class="type">void</span>            <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line">  <span class="type">void</span>            <span class="title function_">kinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// vm.c</span></span><br><span class="line">+ <span class="type">pte_t</span> *         <span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span>, uint64, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>riscv.h</code>：添加 <code>PTE_COWPG</code> 定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COWPG (1L &lt;&lt; 8)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>kalloc.c</code>：添加一些 rc 的函数，修改 <code>kalloc()</code> 和 <code>kfree()</code>。需要注意操作 rc 时的加锁时机。这里的代码优化空间很大，我在这里的实现是 <code>kmem.freelist</code> 和 <code>kmem.rc</code> 使用同一把锁，可以再研究一下锁的颗粒度，或者为 rc 单独细分出一个锁。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="meta">#<span class="keyword">define</span> RC_SZ PHYSTOP &gt;&gt; PGSHIFT</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">+   uint8 rc[RC_SZ];</span><br><span class="line">  &#125; kmem;</span><br><span class="line"></span><br><span class="line">+ <span class="type">void</span> <span class="title function_">acquire_kmem</span><span class="params">()</span> &#123;</span><br><span class="line">+   acquire(&amp;kmem.lock);</span><br><span class="line">+ &#125;</span><br><span class="line"></span><br><span class="line">+ <span class="type">void</span> <span class="title function_">release_kmem</span><span class="params">()</span> &#123;</span><br><span class="line">+   release(&amp;kmem.lock);</span><br><span class="line">+ &#125;</span><br><span class="line"></span><br><span class="line">+ <span class="type">void</span> <span class="title function_">add_rc</span><span class="params">(uint64 a)</span> &#123;</span><br><span class="line">+   ++kmem.rc[a &gt;&gt; PGSHIFT];</span><br><span class="line">+ &#125;</span><br><span class="line"></span><br><span class="line">+ <span class="type">void</span> <span class="title function_">sub_rc</span><span class="params">(uint64 a)</span> &#123;</span><br><span class="line">+   --kmem.rc[a &gt;&gt; PGSHIFT];</span><br><span class="line">+ &#125;</span><br><span class="line"></span><br><span class="line">+ <span class="type">int</span> <span class="title function_">get_rc</span><span class="params">(uint64 a)</span> &#123;</span><br><span class="line">+   <span class="keyword">return</span> kmem.rc[a &gt;&gt; PGSHIFT];</span><br><span class="line">+ &#125;</span><br><span class="line"></span><br><span class="line">+ <span class="type">void</span> <span class="title function_">set_rc</span><span class="params">(uint64 a, <span class="type">int</span> rc)</span> &#123;</span><br><span class="line">+   kmem.rc[a &gt;&gt; PGSHIFT] = rc;</span><br><span class="line">+ &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>下面对 <code>freerange()</code> 函数的修改：该函数在 xv6 启动时调用，并对每个 page 调用一次 <code>kfree()</code> ，由于 <code>kfree()</code> 会将所对应 page 的 rc 减 1，我们需要在 <code>kfree()</code> 调用之前将所对应的 page 的 rc 置为 1，否则会导致系统初始化后这些 page 的 rc 为 -1，引起未知的错误。这里不用为 rc 加锁的原因是 vx6 启动时只会使用一个核，不会产生竞争问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">void</span></span><br><span class="line">  <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">-   <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">+   <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE) &#123;</span><br><span class="line">+     kmem.rc[((uint64)p) &gt;&gt; PGSHIFT] = <span class="number">1</span>;</span><br><span class="line">    kfree(p);</span><br><span class="line">+   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>下面是 <code>kalloc()</code> 和 <code>kfree()</code> 的修改，注意锁的操控时机：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">void</span></span><br><span class="line">  <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">      panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">+   acquire(&amp;kmem.lock);</span><br><span class="line">+   <span class="type">int</span> rc = get_rc((uint64) pa);</span><br><span class="line">+   <span class="keyword">if</span> (rc == <span class="number">0</span>)</span><br><span class="line">+     panic(<span class="string">&quot;kfree: bad rc&quot;</span>);</span><br><span class="line">+   sub_rc((uint64) pa);</span><br><span class="line">+   <span class="keyword">if</span> (get_rc((uint64) pa) != <span class="number">0</span>) &#123;</span><br><span class="line">+     release(&amp;kmem.lock);</span><br><span class="line">+     <span class="keyword">return</span>;</span><br><span class="line">+   &#125;</span><br><span class="line">    <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">    <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line">-   acquire(&amp;kmem.lock);</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span> *</span><br><span class="line">  <span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r = kmem.freelist;</span><br><span class="line">-   <span class="keyword">if</span>(r)</span><br><span class="line">+   <span class="keyword">if</span>(r) &#123;</span><br><span class="line">+     kmem.freelist = r-&gt;next;</span><br><span class="line">+     <span class="keyword">if</span> (get_rc((uint64) r) != <span class="number">0</span>)</span><br><span class="line">+       panic(<span class="string">&quot;kalloc: bad rc&quot;</span>);</span><br><span class="line">+     add_rc((uint64) r);</span><br><span class="line">+   &#125;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(r)</span><br><span class="line">      <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>vm.c:uvmcopy</code>：删除原来的分配内存的代码，取而代之的是仅对 pte 的修改。注意：对 rc 的操作需要加锁。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa, i;</span><br><span class="line">    uint flags;</span><br><span class="line">-   <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">      <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">      pa = PTE2PA(*pte);</span><br><span class="line">      flags = PTE_FLAGS(*pte);</span><br><span class="line">-     <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">-       <span class="keyword">goto</span> err;</span><br><span class="line">-     memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">+     <span class="keyword">if</span> (flags &amp; PTE_W) &#123;</span><br><span class="line">+       flags &amp;= ~PTE_W;</span><br><span class="line">+       flags |= PTE_COWPG;</span><br><span class="line">+       *pte = PA2PTE(pa) | flags;</span><br><span class="line">+     &#125;</span><br><span class="line">-     <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">+     <span class="keyword">if</span>(mappages(new, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">-       kfree(mem);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">      &#125;</span><br><span class="line">+     acquire_kmem();  <span class="comment">// NOTE!!!</span></span><br><span class="line">+     add_rc(pa);</span><br><span class="line">+     release_kmem();  <span class="comment">// NOTE!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   err:</span><br><span class="line">    uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>trap.c:usertrap</code>：在判断 scause 的分支中插入一段判断 15 号 code 的代码即可，这里我在处理 <code>PTE_COWPG</code> 的 page 时做了一个优化：当产生 page fault 的地址的 rc 为 1 时不再做重新分配内存，复制，释放原内存的操作，而是直接修改原来 pte 的 flag 使其拥有 <code>PTE_W</code>，并移除掉 <code>PTE_COWPG</code> 标记。老样子，还是得注意锁的使用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cause == <span class="number">15</span>) &#123;</span><br><span class="line">    uint64 stval = r_stval();</span><br><span class="line">    <span class="keyword">if</span> (stval &gt; p-&gt;sz || stval &gt;= MAXVA) &#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    stval = PGROUNDDOWN(stval);</span><br><span class="line">    <span class="type">pte_t</span> *pte = walk(p-&gt;pagetable, stval, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    uint64 pa = PTE2PA(*pte);</span><br><span class="line">    uint flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span> (pa == <span class="number">0</span> || (flags &amp; PTE_COWPG) == <span class="number">0</span>) &#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    flags &amp;= ~PTE_COWPG;</span><br><span class="line">    flags |= PTE_W;</span><br><span class="line">    acquire_kmem();</span><br><span class="line">    <span class="type">int</span> rc = get_rc(pa);</span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">      panic(<span class="string">&quot;usertrap: bad rc&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">1</span>) &#123;</span><br><span class="line">      *pte |= PTE_W;</span><br><span class="line">      *pte &amp;= ~PTE_COWPG;</span><br><span class="line">      release_kmem();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release_kmem();</span><br><span class="line">      uint64 mem = (uint64) kalloc();</span><br><span class="line">      <span class="keyword">if</span> (mem == <span class="number">0</span>) &#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br><span class="line">      memmove((<span class="type">char</span>*)mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">      <span class="comment">// <span class="doctag">NOTE:</span> cannot use sub_rc(pa)</span></span><br><span class="line">      kfree((<span class="type">void</span> *) pa);</span><br><span class="line">      *pte = PA2PTE(mem) | flags;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>代码中有一段不能使用 <code>sub_rc()</code> 的注释，原因如下：在 <code>CPUS=1</code> 的参数下使用是没有问题的，但若是在多核模式中运行，在中间一段没有持有锁的时期，其他进程也许会修改 rc 的数量，此时仅仅调用 <code>sub_rc()</code> 可能导致 rc 为 0 却没有被释放的情况。</p>
<ul>
<li><code>vm.c:copyout</code>：和 <code>usertrap()</code> 的修改如出一辙，不多解释：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">int</span></span><br><span class="line">  <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">  &#123;</span><br><span class="line">    uint64 n, va0, pa0;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      va0 = PGROUNDDOWN(dstva);</span><br><span class="line">      pa0 = walkaddr(pagetable, va0);</span><br><span class="line">      <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">+     <span class="keyword">if</span> (va0 &gt;= MAXVA)</span><br><span class="line">+       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">+     va0 = PGROUNDDOWN(va0);</span><br><span class="line">+     <span class="type">pte_t</span> *pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line">+     <span class="keyword">if</span> (*pte &amp; PTE_COWPG) &#123;</span><br><span class="line">+       uint64 pa = PTE2PA(*pte);</span><br><span class="line">+       uint16 flag = PTE_FLAGS(*pte);</span><br><span class="line">+       flag &amp;= ~PTE_COWPG;</span><br><span class="line">+       flag |= PTE_W;</span><br><span class="line">+       acquire_kmem();</span><br><span class="line">+       <span class="type">int</span> rc = get_rc(pa);</span><br><span class="line">+       <span class="keyword">if</span> (rc == <span class="number">1</span>) &#123;</span><br><span class="line">+         *pte = PA2PTE(pa) | flag;</span><br><span class="line">+         release_kmem();</span><br><span class="line">+       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+         release_kmem();</span><br><span class="line">+         uint64 mem = (uint64) kalloc();</span><br><span class="line">+         <span class="keyword">if</span> (mem == <span class="number">0</span>) &#123;</span><br><span class="line">+           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">+         &#125;</span><br><span class="line">+         memmove((<span class="type">char</span> *) mem, (<span class="type">char</span> *) pa, PGSIZE);</span><br><span class="line">+         acquire_kmem();</span><br><span class="line">+         sub_rc(pa);</span><br><span class="line">+         release_kmem();</span><br><span class="line">+         *pte = PA2PTE(mem) | flag;</span><br><span class="line">+         pa0 = mem;</span><br><span class="line">+       &#125;</span><br><span class="line">+     &#125;</span><br><span class="line">  </span><br><span class="line">      n = PGSIZE - (dstva - va0);</span><br><span class="line">      <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">        n = len;</span><br><span class="line">      memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line">  </span><br><span class="line">      len -= n;</span><br><span class="line">      src += n;</span><br><span class="line">      dstva = va0 + PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这个 lab 总体思路和实现不是很难，但却让我究竟了几个小时，主要就是卡在了引用计数的同步问题上，这个一定要多加注意。可以通过先添加 <code>CPUS=1</code> 参数看看测试能否通过，用这种方式判断是否问题出在同步上。</p>
<p>测试通过结果没有什么意义，就懒得贴上来了（</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kujourinka.github.io/2022/12/04/6s018_lab5cow/" data-id="cll2gun8p0002d8p01fc97get" data-title="6.s018 lab5 cow(Copy-on-write fork) 踩坑指南" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux_kernel_stack_switch" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/13/linux_kernel_stack_switch/" class="article-date">
  <time class="dt-published" datetime="2022-06-13T11:00:00.000Z" itemprop="datePublished">2022-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/13/linux_kernel_stack_switch/">将 linux 0.11 进程切换由基于 tss 改写为基于内核栈</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>来自哈工大李治军老师的操作系统网课 <a target="_blank" rel="noopener" href="https://www.icourse163.org/learn/HIT-1002531008">link</a> 实验四。</p>
<p>具体是 linux 0.11 使用 CPU 提供的 TSS 进行进程的切换，虽然使用这个机制能很方便地进行进程切换，但是效率不太高，于是要求我们在课程的理解上将其改写为基于内核栈（kernel stack）的进程切换。</p>
<h4 id="写在前面的废话"><a href="#写在前面的废话" class="headerlink" title="写在前面的废话"></a>写在前面的废话</h4><p>我的理解能力有限，外加周围没有人能指导，摸爬滚打查阅了数天的资料，理解了其中大致的原理，故才有了下面这篇文章。我认为只是看看网文，大致了解个思路然后心里想着“哦好像是这样”，然后草草了然进入下一课是不行的。你得了解核心代码每一行做了什么，为什么这样做，反复问自己。</p>
<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>下面写一些前置知识，了解的可以当做复习，不了解的必须了解啊，有助于下文的理解。</p>
<h5 id="中断做了什么"><a href="#中断做了什么" class="headerlink" title="中断做了什么"></a>中断做了什么</h5><p>李老师在<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1d4411v7u7?p=5">第五课</a>中借用系统调用的实现顺便讲了讲中断是怎么做的，简单来说，就是用 <code>int</code> 指令发出中断信号，系统根据 <code>int</code> 后的操作数选择提前注册好的中断处理函数进行中断处理。举个例，<code>int 0x80</code> 指令发出后会陷入到系统调用，执行 <code>system_call</code> （定义于 <code>kernel/system_call.s</code>）中的指令。为什么这条指令执行后会直接执行 <code>system_call</code>？linux 在初始化时调用了 <code>set_system_gate(0x80, &amp;system_call)</code> 将 <code>system_call</code> 注册为 <code>0x80</code> 号中断的处理函数。<strong>后文提到的中断默认以系统调用作为例子。</strong></p>
<p>执行 <code>int</code> 指令后由用户栈陷入内核栈，<strong>请注意，<code>int</code> 调用后并不是马上执行 <code>system_call</code> 中的代码</strong>。在 <code>int</code> 调用后，<code>system_call</code> 执行前，需要把用户态对应的一些重要寄存器保存，用以中断返回后的现场恢复。具体的，我们需要依次保存 <code>ss</code>（用户数据栈底），<code>sp</code>（用户数据栈顶），<code>eflags</code>（标志寄存器），<code>cs</code>，<code>ip</code> 这五个寄存器的值到内核栈。随后进入到 <code>syscall</code>，此时内核栈是这样的：</p>
<p><img src="https://raw.githubusercontent.com/KujouRinka/flowchart/master/20220613/kernel_stack0.svg" alt="kernel stack0"></p>
<p>随后执行 <code>system_call</code> 中的代码。而要从内核栈返回到用户栈，需要使用 <code>iret</code> 指令，此时必须保证内核栈中保存有用于恢复用户态的信息，如上图。</p>
<h5 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h5><p>TSS 的结构由 <code>include/linux/sched.h</code> 中的 <code>struct tss_struct</code> 定义。在 linux 0.11 代码中，TSS 用于切换进程时，将当前 CPU 中寄存器的所有值保存到当前进程的 TSS，随后使用即将切换的进程的 TSS 中的信息来填写 CPU 中的寄存器，这样就完成了进程的切换。其中较重要的寄存器是 <code>ss</code>，<code>sp</code>，<code>cs</code>，<code>ip</code>。注意，这四个寄存器，不管是现在 CPU 中的值，还是即将切换的进程的 TSS 中所保存的这四个寄存器的值，记录的都是相应的<strong>内核态</strong>的状态。</p>
<h5 id="switch-to-函数"><a href="#switch-to-函数" class="headerlink" title="switch_to 函数"></a>switch_to 函数</h5><p>定义于 <code>include/linux/sched.h</code>。<a target="_blank" rel="noopener" href="https://blog.csdn.net/smallmuou/article/details/6837087">这篇博文</a>解释地非常好，重点理解其中的 <code>ljmp</code> 指令，顺便复习一下 GDT 表的结构。</p>
<h5 id="其他的"><a href="#其他的" class="headerlink" title="其他的"></a>其他的</h5><p>时刻记住 <code>call</code> 相当于 <code>push ip</code>，<code>ret</code> 相当于 <code>pop ip</code>。</p>
<h4 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h4><p>首先应该明确，修改进程切换的方法同时需要修改 <code>fork()</code> 系统调用，因为 linux 启动时需要通过 <code>fork()</code> 启动 shell。</p>
<p>首先来看 <code>system_call</code> 中的部分代码，不重要的省去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">system_call:</span><br><span class="line">	cmpl $nr_system_calls-1,%eax</span><br><span class="line">	ja bad_sys_call</span><br><span class="line">	push %ds</span><br><span class="line">	push %es</span><br><span class="line">	push %fs</span><br><span class="line">	pushl %edx</span><br><span class="line">	pushl %ecx</span><br><span class="line">	pushl %ebx</span><br><span class="line">	...</span><br><span class="line">	call sys_call_table(,%eax,4)</span><br></pre></td></tr></table></figure>

<p>入栈一些寄存器，使用 <code>call</code> 调用真正的系统调用函数是，内核栈如下图：</p>
<p><img src="https://raw.githubusercontent.com/KujouRinka/flowchart/master/20220613/kernel_stack1.svg" alt="kernel stack1"></p>
<p>系统调用执行完成后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pushl %eax</span><br><span class="line">movl current,%eax</span><br><span class="line">cmpl $0,state(%eax)		# state</span><br><span class="line">jne reschedule</span><br><span class="line">cmpl $0,counter(%eax)		# counter</span><br><span class="line">je reschedule</span><br></pre></td></tr></table></figure>

<p>将 <code>eax</code> 入内核栈，其中两个 <code>cmpl</code> 分别判断进程的状态（运行？挂起？…）和时间片，根据判断结果决定是否跳转到 <code>reschedule</code> 处，<code>reschedule</code> 定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reschedule:</span><br><span class="line">	pushl $ret_from_sys_call</span><br><span class="line">	jmp schedule</span><br></pre></td></tr></table></figure>

<p>将 <code>ret_from_sys_call</code> 的地址入栈，调用 <code>schedule</code> 函数进行进程切换。其中，对于 <code>ret_from_sys_call</code>，其核心为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ret_from_sys_call:</span><br><span class="line">	...</span><br><span class="line">	popl %eax</span><br><span class="line">	popl %ebx</span><br><span class="line">	popl %ecx</span><br><span class="line">	popl %edx</span><br><span class="line">	pop %fs</span><br><span class="line">	pop %es</span><br><span class="line">	pop %ds</span><br><span class="line">	iret</span><br></pre></td></tr></table></figure>

<p>将内核栈中的内容 pop 直到仅剩 <code>ss</code>，<code>sp</code>，<code>eflags</code>，<code>cs</code>，<code>ip</code>，这些正好是恢复到用户态需要的寄存器信息。随后调用 <code>iret</code> 回到用户态。</p>
<h4 id="schedule-和-switch-to"><a href="#schedule-和-switch-to" class="headerlink" title="schedule 和 switch_to"></a>schedule 和 switch_to</h4><p><code>schedule</code> 是一个 C 函数，跳转到 <code>schedule</code> 函数时，内核栈中的内容：</p>
<p><img src="https://raw.githubusercontent.com/KujouRinka/flowchart/master/20220613/kernel_stack3.svg" alt="kernel stack3"></p>
<p>此时 <code>schedule</code>，中的调度算法计算出下一个切换的进程，并调用 <code>switch_to</code> 切换至这个进程。调用 <code>switch_to</code> 前，内核栈中的内容是不变的。</p>
<p><code>switch_to</code> 的讲解见<a target="_blank" rel="noopener" href="https://blog.csdn.net/smallmuou/article/details/6837087">这篇博文</a>，写得非常好。</p>
<h4 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork() 函数"></a>fork() 函数</h4><p><code>fork()</code>  原始的函数的讲解见李老师的<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1d4411v7u7?p=12">视频</a>后半段，解释地非常清楚。</p>
<h4 id="改写注意事项"><a href="#改写注意事项" class="headerlink" title="改写注意事项"></a>改写注意事项</h4><p>改写时一定要清楚程序运行到改写处时，此时寄存器中的值和内核栈中的值。</p>
<h4 id="改写-switch-to-函数"><a href="#改写-switch-to-函数" class="headerlink" title="改写 switch_to() 函数"></a>改写 switch_to() 函数</h4><p>将原先的 <code>switch_to</code> 宏定义删除，在 <code>system_call.s</code> 添加 <code>switch_to</code> 的<strong>汇编</strong>实现。</p>
<p>我们定义 <code>long switch_to(long pnext, long ldt)</code> 为函数签名，其中 <code>pnext</code> 为指向一个 <code>task_struct</code> 的指针，即为 PCB，<code>ldt</code> 为其对应的 LDT 描述符地址。因此在 <code>schedule()</code> 中调用 <code>switch(pnext, _LDT(next))</code> 并进入 <code>switch_to</code> 函数体后，<code>8(%ebp)</code> 为 <code>pnext</code>，<code>12(%ebp)</code>为<code>_LDT(next)</code>，这是由 C 函数调用时将参数和返回值逆序压入栈中所决定的。下面贴上网络上给出的 <code>switch_to</code> 完整具体实现，并选择一些解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">switch_to:</span><br><span class="line">	pushl %ebp</span><br><span class="line">	movl %esp,%ebp</span><br><span class="line">	pushl %ecx</span><br><span class="line">	pushl %ebx</span><br><span class="line">	pushl %eax</span><br><span class="line">	movl 8(%ebp),%ebx</span><br><span class="line">	cmpl %ebx,current</span><br><span class="line">	je 1f</span><br><span class="line">	movl %ebx,%eax</span><br><span class="line">	xchgl %eax,current</span><br><span class="line">	movl tss,%ecx</span><br><span class="line">	addl $4096,%ebx</span><br><span class="line">	movl %ebx,4(%ecx)</span><br><span class="line">	movl %esp,12(%eax)</span><br><span class="line">	movl 8(%ebp),%ebx</span><br><span class="line">	movl 12(%ebx),%esp</span><br><span class="line">	movl 12(%ebp),%ecx	</span><br><span class="line">	lldt %cx</span><br><span class="line">	movl $0x17,%ecx</span><br><span class="line">	mov %cx,%fs</span><br><span class="line">	cmpl %eax,last_task_used_math</span><br><span class="line">	jne 1f</span><br><span class="line">	clts</span><br><span class="line">1:</span><br><span class="line">	popl %eax</span><br><span class="line">	popl %ebx</span><br><span class="line">	popl %ecx</span><br><span class="line">	popl %ebp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>从第 1 行到第 7 行所作的任务是处理 C 调用的帧栈；保存一些寄存器的值，因为这些寄存器稍后将使用，第 7 行 <code>movl 8(%ebp),%ebx</code> 执行完毕后，内核栈的状态：</p>
<p><img src="https://raw.githubusercontent.com/KujouRinka/flowchart/master/20220613/kernel_stack4.svg" alt="kernel stack4"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl 8(%ebp),%ebx</span><br></pre></td></tr></table></figure>

<p>将 <code>pnext</code>，即新进程的 PCB 赋给 <code>ebx</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpl %ebx,current</span><br><span class="line">je 1f</span><br></pre></td></tr></table></figure>

<p>比较新进程的 PBC 与当前进程的 PCB，若相同，调到标签 1 处，即什么也不做返回函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl %ebx,%eax</span><br><span class="line">xchgl %eax,current</span><br></pre></td></tr></table></figure>

<p>执行完这两句，<code>ebx</code> 和 <code>current</code> 值为新的进程，<code>eax</code> 为当前进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl tss,%ecx</span><br><span class="line">addl $4096,%ebx</span><br><span class="line">movl %ebx,4(%ecx)</span><br></pre></td></tr></table></figure>

<p>此处的 tss 为我们自己定义的全局变量，作为所有进程公共的 TSS 表，我们在 <code>kernel/sched.h</code> 中加上 <code>struct tss_struct *global_tss = &amp;(init_task.task.tss);</code> 一句，定义全局 TSS。</p>
<p>对于 <code>addl $4096,%ebx</code>，由于 <code>ebx</code> 中此前的值为新的进程的 PCB，对于 linux 0.11 其一页内存大小为 4k。对于一个进程，其 PCB 存储在一页内存的低地址，其内核栈在该页内存的高地址，结构如图：</p>
<p><img src="https://raw.githubusercontent.com/KujouRinka/flowchart/master/20220613/pcb.svg" alt="pcb"></p>
<p>随后 <code>movl %ebx,4(%ecx)</code>，将内核栈栈顶赋值给 TSS 的 <code>sp0</code> 字段，该字段在 <code>tss_struct</code> 结构的第 4 个偏移位置，至于为什么要设置 <code>sp0</code>，引用一段来自<a target="_blank" rel="noopener" href="https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/exp4_process/%E5%9C%A8Linux-0.11%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E6%A0%88%E5%88%87%E6%8D%A2%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2.md">这里</a>的解释：</p>
<blockquote>
<p>虽然所有进程共用一个 tss，但不同进程的内核栈是不同的，所以在每次进程切换时，需要更新 tss 中 esp0 的值，让它指向新的进程的内核栈，并且要指向新的进程的内核栈的栈底，即要保证此时的内核栈是个空栈，帧指针和栈指针都指向内核栈的栈底。 这是因为新进程每次中断进入内核时，其内核栈应该是一个空栈。</p>
</blockquote>
<p>接下来三句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl %esp,12(%eax)</span><br><span class="line">movl 8(%ebp),%ebx</span><br><span class="line">movl 12(%ebx),%esp</span><br></pre></td></tr></table></figure>

<p><code>eax</code> 为当前进程 PCB。</p>
<p>这里我们需要先修改 <code>include/linux/sched.h</code> 中 <code>task_struct</code> ，即 PCB 的定义。新增一个 <code>long kernel_stack</code> 字段于结构体第四个字段，因此表现为相对于结构体首地址偏移 12 个单位。</p>
<p>这三句的作用是，将当前 <code>esp</code> ，即当前内核栈栈顶指针存储到 PCB 中；使 <code>ebx</code> 指向新进程 PCB，将新进程 PCB 的 <code>esp</code> 即内核栈栈顶指针赋值给 <code>esp</code> 寄存器。<strong>此时已经完成内核栈由当前进程到新进程的切换</strong>。</p>
<p>接下来两句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl 12(%ebp),%ecx</span><br><span class="line">lldt %cx</span><br></pre></td></tr></table></figure>

<p>切换 LDT。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl $0x17,%ecx</span><br><span class="line">mov %cx,%fs</span><br><span class="line">cmpl %eax,last_task_used_math</span><br><span class="line">jne 1f</span><br><span class="line">clts</span><br></pre></td></tr></table></figure>

<p>为固定指令，后续课程会讲到，目前不做要求。具体解释引用<a target="_blank" rel="noopener" href="https://www.lanqiao.cn/courses/115/learning">蓝桥云课</a>中一段解释，目前我还不了解：</p>
<blockquote>
<p>这两句代码的含义是重新取一下段寄存器 fs 的值，这两句话必须要加、也必须要出现在切换完 LDT 之后，这是因为在实践项目 2 中曾经看到过 fs 的作用——通过 fs 访问进程的用户态内存，LDT 切换完成就意味着切换了分配给进程的用户态内存地址空间，所以前一个 fs 指向的是上一个进程的用户态内存，而现在需要执行下一个进程的用户态内存，所以就需要用这两条指令来重取 fs。</p>
<p>不过，细心的读者可能会发现：fs 是一个选择子，即 fs 是一个指向描述符表项的指针，这个描述符才是指向实际的用户态内存的指针，所以上一个进程和下一个进程的 fs 实际上都是 0x17，真正找到不同的用户态内存是因为两个进程查的 LDT 表不一样，所以这样重置一下 <code>fs=0x17</code> 有用吗，有什么用？要回答这个问题就需要对段寄存器有更深刻的认识，实际上段寄存器包含两个部分：显式部分和隐式部分，如下图给出实例所示，就是那个著名的 <code>jmpi 0, 8</code>，虽然我们的指令是让 <code>cs=8</code>，但在执行这条指令时，会在段表（GDT）中找到 8 对应的那个描述符表项，取出基地址和段限长，除了完成和 eip 的累加算出 PC 以外，还会将取出的基地址和段限长放在 cs 的隐藏部分，即图中的基地址 0 和段限长 7FF。为什么要这样做？下次执行 <code>jmp 100</code> 时，由于 cs 没有改过，仍然是 8，所以可以不再去查 GDT 表，而是直接用其隐藏部分中的基地址 0 和 100 累加直接得到 PC，增加了执行指令的效率。现在想必明白了为什么重新设置 fs&#x3D;0x17 了吧？而且为什么要出现在切换完 LDT 之后？</p>
</blockquote>
<p>最后，标签 1 后的代码为函数返回所做的工作，最后返回到系统调用 <code>iret</code>，退出中断。</p>
<h4 id="改写-fork-函数"><a href="#改写-fork-函数" class="headerlink" title="改写 fork() 函数"></a>改写 fork() 函数</h4><p>调用 <code>fork()</code> 函数时，函数调用链大致为 <code>fork(C)-&gt;syscall(asm)-&gt;sys_fork(asm)-&gt;copy_process(C)</code>。</p>
<p>进入 <code>copy_process</code> 前，内核栈内容如下图：</p>
<p><img src="https://raw.githubusercontent.com/KujouRinka/flowchart/master/20220613/kernel_stack5.svg" alt="kernel stack5"></p>
<p>对应函数签名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr,<span class="type">long</span> ebp,<span class="type">long</span> edi,<span class="type">long</span> esi,<span class="type">long</span> gs,<span class="type">long</span> none,</span></span><br><span class="line"><span class="params">      <span class="type">long</span> ebx,<span class="type">long</span> ecx,<span class="type">long</span> edx,</span></span><br><span class="line"><span class="params">      <span class="type">long</span> fs,<span class="type">long</span> es,<span class="type">long</span> ds,</span></span><br><span class="line"><span class="params">      <span class="type">long</span> eip,<span class="type">long</span> cs,<span class="type">long</span> eflags,<span class="type">long</span> esp,<span class="type">long</span> ss)</span></span><br></pre></td></tr></table></figure>

<p>在 <code>copy_process</code> 中使用 <code>p = get_free_page()</code> 获得一页新的内存，该内存即为新进程的内核栈和 PCB 所使用的的空间，<code>p</code> 指向 PCB 首地址，我们添加下面的代码设置子进程的内核栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> *kernel_stack_top = (<span class="type">long</span> *)(PAGE_SIZE + (<span class="type">long</span>)p);</span><br><span class="line"><span class="comment">// prepare info for user stack</span></span><br><span class="line">*(--kernel_stack_top) = ss &amp; <span class="number">0xffff</span>;</span><br><span class="line">*(--kernel_stack_top) = esp;</span><br><span class="line">*(--kernel_stack_top) = eflags;</span><br><span class="line">*(--kernel_stack_top) = cs &amp; <span class="number">0xffff</span>;</span><br><span class="line">*(--kernel_stack_top) = eip;</span><br><span class="line">*(--kernel_stack_top) = ds &amp; <span class="number">0xffff</span>;</span><br><span class="line">*(--kernel_stack_top) = es &amp; <span class="number">0xffff</span>;</span><br><span class="line">*(--kernel_stack_top) = fs &amp; <span class="number">0xffff</span>;</span><br><span class="line">*(--kernel_stack_top) = gs &amp; <span class="number">0xffff</span>;</span><br><span class="line">*(--kernel_stack_top) = esi;</span><br><span class="line">*(--kernel_stack_top) = edi;</span><br><span class="line">*(--kernel_stack_top) = edx;</span><br><span class="line">*(--kernel_stack_top) = (<span class="type">long</span>)first_ret_from_fork;</span><br><span class="line">*(--kernel_stack_top) = ebp;</span><br><span class="line">*(--kernel_stack_top) = ecx;</span><br><span class="line">*(--kernel_stack_top) = ebx;</span><br><span class="line">*(--kernel_stack_top) = <span class="number">0</span>;	<span class="comment">// fork return 0 in child process</span></span><br><span class="line">p-&gt;kernel_stack = (<span class="type">long</span>)kernel_stack_top;</span><br></pre></td></tr></table></figure>

<p>第一条指令将 <code>kernel_stack_top</code> 设置为内核栈栈顶，后面依次填写数据，最后一条指令记录子进程的内核栈栈顶，也就是 <code>sp</code> 指针位置。</p>
<p>对于子进程，<code>fork()</code> 返回 0，因此将内核栈栈顶，也就是对应的 <code>eax</code> 的位置设置为 0。同时可以删掉 <code>copy_process </code> 中一些不必要的代码，不删除不影响结果。</p>
<h4 id="改写后的运行逻辑"><a href="#改写后的运行逻辑" class="headerlink" title="改写后的运行逻辑"></a>改写后的运行逻辑</h4><p>现在假设我们将所有修改应用，我们现在分析 <code>fork()</code> 后子进程的行为。</p>
<p>当 <code>switch_to</code> 切换到子进程并运行到其中的标签 1 处，依次对 <code>eax</code>，<code>ebx</code>，<code>ecx</code>，<code>ebp</code> 进行出栈并调用 <code>ret</code>，调用 <code>ret</code> 时内核栈栈顶为 <code>first_ret_from_fork()</code> 函数，考虑这个函数应该做什么。既然子进程已经切换完毕，我们则需要从内核态返回到用户态执行用户代码，因此该函数需要承担从内核态返回的任务，调用 <code>first_ret_from_fork()</code> 时，此时对应的<strong>子进程</strong>内核栈的内容如下：</p>
<p><img src="https://raw.githubusercontent.com/KujouRinka/flowchart/master/20220613/kernel_stack6.svg" alt="kernel stack6"></p>
<p>很自然写出 <code>first_ret_from_fork()</code> 的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">first_ret_from_fork:</span><br><span class="line">	popl %edx</span><br><span class="line">	popl %edi</span><br><span class="line">	popl %esi</span><br><span class="line">	pop %gs</span><br><span class="line">	pop %fs</span><br><span class="line">	pop %es</span><br><span class="line">	pop %ds</span><br><span class="line">	iret</span><br></pre></td></tr></table></figure>

<h4 id="写在后面的废话"><a href="#写在后面的废话" class="headerlink" title="写在后面的废话"></a>写在后面的废话</h4><p>上面记录了一些我认为较难理解的细节，我的完整的修改过程记录在了<a target="_blank" rel="noopener" href="https://github.com/KujouRinka/linux-0.11/commit/264072e0d97567eada96cb3b47d4d3d5193e3da0">这个 commit</a> 里。个人认为这个更像是对于线程的修改，因为父子进程共享了一个用户数据栈，实际写代码验证也正是如此，修改 <code>fork()</code> 后子进程中的变量会对父进程中的变量造成影响，反之亦然。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kujourinka.github.io/2022/06/13/linux_kernel_stack_switch/" data-id="cll2gun8s0005d8p0eajq52kl" data-title="将 linux 0.11 进程切换由基于 tss 改写为基于内核栈" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-brief_taking_on_creational" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/07/brief_taking_on_creational/" class="article-date">
  <time class="dt-published" datetime="2022-03-07T06:18:00.000Z" itemprop="datePublished">2022-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/07/brief_taking_on_creational/">浅谈创建型设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>通常认为创建型构造模式（creational design pattern）共有这五种 <code>Abstract Factory</code>，<code>Builder</code>，<code>Factory Method</code>，<code>Prototype</code>，<code>Singleton</code>。书中所对应的中文一般分别为抽象工厂，生成器，工厂方法，原型，单件。</p>
<p>This is a draft.</p>
<p>To be continue…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kujourinka.github.io/2022/03/07/brief_taking_on_creational/" data-id="cll2gun8q0003d8p0d7jc7kvb" data-title="浅谈创建型设计模式" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-implement_dup2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/24/implement_dup2/" class="article-date">
  <time class="dt-published" datetime="2022-02-24T13:58:00.000Z" itemprop="datePublished">2022-02-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/24/implement_dup2/">实现 dup2() 函数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>来自 APUE 上的第 3.3 题，原文如下：</p>
<blockquote>
<p>编写一个与 3.12 节中 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/dup.2.html">dup2</a> 功能相同的函数，要求不调用 fcntl 函数，并且要有正确的出错处理。</p>
</blockquote>
<p>函数原型是 <code>int dup2(int fd, int fd2)</code> ，作用是复制文件描述符 <code>fd</code>  ，使 <code>fd2</code> 为新的描述符的值，即 <code>fd</code> 与 <code>fd2</code> 共享同一个文件表项。若 <code>fd2</code> 已经打开，则先将其关闭。</p>
<p>很有意思的一个题。由于要求不调用 <code>fcntl</code> ，则基本思路为使用 <code>dup</code> 函数实现之。</p>
<h4 id="实现基本逻辑-myDup2"><a href="#实现基本逻辑-myDup2" class="headerlink" title="实现基本逻辑 myDup2"></a>实现基本逻辑 <code>myDup2</code></h4><p>我们令自己实现的函数原型为 <code>int myDup2(int fd, int fd2)</code> ，先考虑该函数的基本逻辑。</p>
<p>我们让所有的 <code>errno</code> 处理在该函数进行处理。</p>
<p>首先，我们需要要求传入函数的两个文件描述符必须有效，于是有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">myDup2</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> fd2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max_fd = getdtablesize();    <span class="comment">// 获取文件描述符表的大小</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span> || fd &gt;= max_fd || fd2 &lt; <span class="number">0</span> || fd2 &gt;= max_fd || !isOpen(fd)) &#123;</span><br><span class="line">        errno = EBADF;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>getdtablesize()</code> 用于获取文件描述符表的的大小，限制了系统最大的文件描述符。</p>
<p><code>isOpen</code> 函数用于判断给定文件描述符是否为已打开的文件描述符，后续实现。</p>
<p>若给定的文件描述符 <code>fd</code> 和 <code>fd2</code> 无效，则设置 <code>errno</code> 并返回 <code>-1</code> 。</p>
<p>接下来，由 <code>dup2</code> 的定义，若 <code>fd</code> 等于 <code>fd2</code> ，则 <code>dup2</code> 返回 <code>fd2</code> ，而不关闭它；以及如果 <code>fd2</code> 已经打开，则先将其关闭：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (fd == fd2)</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    <span class="keyword">if</span> (isOpen(fd2))</span><br><span class="line">        close(fd2);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>接下来为 <code>myDup2</code> 的核心逻辑。根据「 <code>dup</code> 返回的新文件描述符一定是当前可用文件描述符的最小数值」，基本思路为不断使用 <code>dup(fd)</code> 直至其返回值与 <code>fd2</code> 相等，随后将之前使用 <code>dup</code> 打开的文件描述符关闭即可。</p>
<p>考虑到需要记录由 <code>dup(fd)</code> 创建的文件描述符用于删除，加之 <code>C</code> 需要手动实现类似动态数组之类的数据结构，我们<del>偷懒</del>使用递归替代手动存储的工作。我们将这个操作使用 <code>int recursiveDup(int fd, int fd2)</code> 完成，我们定义返回值为成功复制后的 <code>fd2</code> ，若失败，则返回 <code>-1</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ((fd2 = recursiveDup(fd, fd2)) == <span class="number">-1</span>)</span><br><span class="line">        errno = EBADF;</span><br><span class="line">    <span class="keyword">return</span> fd2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>recursiveDup</code> 后期望得到 <code>fd2</code> 的值，若失败，则设置 <code>errno</code> 。</p>
<h4 id="实现核心递归函数-recursiveDup"><a href="#实现核心递归函数-recursiveDup" class="headerlink" title="实现核心递归函数 recursiveDup"></a>实现核心递归函数 <code>recursiveDup</code></h4><p>首先：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">recursiveDup</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> fd2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> nf = dup(fd);</span><br><span class="line">    <span class="keyword">if</span> (nf == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nf == fd2)</span><br><span class="line">        <span class="keyword">return</span> nf;</span><br><span class="line">    <span class="type">int</span> rf = recursiveDup(fd, fd2);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>dup</code> 复制文件描述符，若失败，返回 <code>-1</code> ，这里并不处理 <code>errno</code> 因为我们将所有的 <code>errno</code> 处理放在 <code>myDup</code> 中。若得到期望的文件描述符的值，返回之。若否，继续递归调用 <code>recursiveDup</code> 直至其产生。</p>
<p>之后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    close(nf);</span><br><span class="line">    <span class="keyword">return</span> rf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭不合要求的 <code>nf</code> 返回结果（不论是否为 <code>-1</code>）。</p>
<h4 id="收尾，实现-isOpen"><a href="#收尾，实现-isOpen" class="headerlink" title="收尾，实现 isOpen"></a>收尾，实现 <code>isOpen</code></h4><p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isOpen</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> old_errno = errno;</span><br><span class="line">    <span class="type">int</span> test_f = dup(fd);</span><br><span class="line">    errno = old_errno;</span><br><span class="line">    <span class="keyword">if</span> (test_f == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(test_f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们利用 <code>dup</code> 函数只能作用于已打开文件描述符的机制进行判断。注意，我们需要对本来的 <code>errno</code> 进行处理，由于我们的 <code>isOpen</code> 仅进行判断，不应对系统本来的 <code>errno</code> 有影响，<code>dup</code> 后需要及时恢复。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isOpen</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> old_errno = errno;</span><br><span class="line">    <span class="type">int</span> test_f = dup(fd);</span><br><span class="line">    errno = old_errno;</span><br><span class="line">    <span class="keyword">if</span> (test_f == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(test_f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">recursiveDup</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> fd2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> nf = dup(fd);</span><br><span class="line">    <span class="keyword">if</span> (nf == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nf == fd2)</span><br><span class="line">        <span class="keyword">return</span> nf;</span><br><span class="line">    <span class="type">int</span> rf = recursiveDup(fd, fd2);</span><br><span class="line">    close(nf);</span><br><span class="line">    <span class="keyword">return</span> rf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myDup2</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> fd2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max_fd = getdtablesize();</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span> || fd &gt;= max_fd || fd2 &lt; <span class="number">0</span> || fd2 &gt;= max_fd || !isOpen(fd)) &#123;</span><br><span class="line">        errno = EBADF;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fd == fd2)</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    <span class="keyword">if</span> (isOpen(fd2))</span><br><span class="line">        close(fd2);</span><br><span class="line">    <span class="keyword">if</span> ((fd2 = recursiveDup(fd, fd2)) == <span class="number">-1</span>)</span><br><span class="line">        errno = EBADF;</span><br><span class="line">    <span class="keyword">return</span> fd2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>个人感觉很有意思的一个题，不断反复利用 <code>dup</code> 函数的性质得到结果。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kujourinka.github.io/2022/02/24/implement_dup2/" data-id="cll2gun8r0004d8p01j2bdvmf" data-title="实现 dup2() 函数" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/08/re0_ss1/">从零写一个 shadowsocks（1）</a>
          </li>
        
          <li>
            <a href="/2023/04/20/simple_impl_for_lazy/">简记一次 rCore 中 sys_sbrk() 与 lazy allocation 的实现</a>
          </li>
        
          <li>
            <a href="/2023/03/21/nic_driver_kara_syscall_he/">从网卡驱动到系统调用</a>
          </li>
        
          <li>
            <a href="/2023/02/08/6824_lab2a_leader_election/">6.824 Lab2A Leader Election 可行方案</a>
          </li>
        
          <li>
            <a href="/2022/12/23/6824_lab1_MapReduce/">6.824 Lab1 MapReduce 快速实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Kujou Rinka<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>